<p align="center"><img src="images/devops_exercises.png"/></p>

:information_source: &nbsp;This repo contains questions and exercises on various technical topics, sometimes related to DevOps and SRE

:bar_chart: &nbsp;There are currently **2138** exercises and questions

:books: &nbsp;To learn more about DevOps and SRE, check the resources in [devops-resources](https://github.com/bregman-arie/devops-resources) repository

:warning: &nbsp;You can use these for preparing for an interview but most of the questions and exercises don't represent an actual interview. Please read [FAQ page](faq.md) for more details

:busts_in_silhouette: &nbsp;Join our [DevOps community](https://www.facebook.com/groups/538897960007080) where we have discussions and share resources on DevOps

:pencil: &nbsp;You can add more exercises by submitting pull requests :) Read about contribution guidelines [here](CONTRIBUTING.md)

****

<!-- ALL-TOPICS-LIST:START -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<center>
<table>
  <tr>
    <td align="center"><a href="exercises/devops/README.md"><img src="images/devops.png" width="70px;" height="75px;" alt="DevOps" /><br /><b>DevOps</b></a></td>
    <td align="center"><a href="exercises/cicd/README.md"><img src="images/cicd.png" width="85px;" height="85px;" alt="cicd"/><br /><b>CI/CD</b></a></td>
    <td align="center"><a href="exercises/git/README.md"><img src="images/git.png" width="80px;" height="75px;" alt="Git"/><br /><b>Git</b></a></td>
    <td align="center"><a href="exercises/ansible/README.md"><img src="images/ansible.png" width="75px;" height="75px;" alt="ansible"/><br /><b>Ansible</b></a></td>
    <td align="center"><a href="#Network"><img src="images/network.png" width="80x;" height="75px;" alt="Network"/><br /><b>Network</b></a></td>
    <td align="center"><a href="#linux"><img src="images/linux.png" width="75x;" height="75px;" alt="Linux"/><br /><b>Linux</b></a></td>

  </tr>
  <tr>
    <td align="center"><a href="exercises/software_development/README.md"><img src="images/programming.png" width="75px;" height="75px;" alt="programming"/><br /><b>Software Development</b></a></td>
    <td align="center"><a href="#python"><img src="images/python.png" width="80px;" height="75px;" alt="Python"/><br /><b>Python</b></a></td>
    <td align="center"><a href="#go"><img src="images/Go.png" width="75px;" height="75px;" alt="go"/><br /><b>Go</b></a></td>
    <td align="center"><a href="exercises/shell/README.md"><img src="images/bash.png" width="70px;" height="75px;" alt="Bash"/><br /><b>Shell Scripting</b></a></td>
    <td align="center"><a href="#kubernetes"><img src="images/kubernetes.png" width="75px;" height="75px;" alt="kubernetes"/><br /><b>Kubernetes</b></a></td>
    <td align="center"><a href="#prometheus"><img src="images/prometheus.png" width="75px;" height="75px;" alt="Prometheus"/><br /><b>Prometheus</b></a></td>
  </tr>
  <tr>
    <td align="center"><a href="exercises/cloud/README.md"><img src="images/cloud.png" width="110px;" height="75px;" alt="Cloud"/><br /><b>Cloud</b></a></td>
    <td align="center"><a href="exercises/aws/README.md"><img src="images/aws.png" width="75px;" height="75px;" alt="aws"/><br /><b>AWS</b></a></td>
    <td align="center"><a href="#azure"><img src="images/azure.png" width="75px;" height="75px;" alt="azure"/><br /><b>Azure</b></a></td>
    <td align="center"><a href="#gcp"><img src="images/googlecloud.png" width="80px;" height="75px;" alt="Google Cloud Platform"/><br /><b>Google Cloud Platform</b></a></td>
    <td align="center"><a href="#openstack"><img src="images/openstack.png" width="75px;" height="75px;" alt="openstack"/><br /><b>OpenStack</b></a></td>
    <td align="center"><a href="exercises/security/README.md"><img src="images/security.png" width="75px;" height="75px;" alt="security"/><br /><b>Security</b></a></td>
  </tr>
  <tr>
    <td align="center"><a href="#operating-system"><img src="images/os.png" width="75px;" height="75px;" alt="Operating System"/><br /><b>Operating System</b></a></td>
    <td align="center"><a href="#monitoring"><img src="images/monitoring.png" width="75px;" height="75px;" alt="Monitoring"/><br /><b>Monitoring</b></a></td>
    <td align="center"><a href="#elastic"><img src="images/elastic.png" width="110px;" height="75px;" alt="Elastic"/><br /><b>Elastic</b></a></td>
    <td align="center"><a href="#virtualization"><img src="images/virtualization.png" width="75px;" height="75px;" alt="Virtualization"/><br /><b>Virtualization</b></a></td>
    <td align="center"><a href="exercises/dns/README.md"><img src="images/dns.png" width="75px;" height="75px;" alt="DNS"/><br /><b>DNS</b></a></td>
    <td align="center"><a href="#Misc"><img src="images/general.png" width="110px;" height="75px;" alt="Misc"/><br /><b>Misc</b></a></td>
  </tr>
  <tr>
    <td align="center"><a href="#testing"><img src="images/testing.png" width="75px;" height="75px;" alt="Testing"/><br /><b>Testing</b></a></td>
    <td align="center"><a href="#databases"><img src="images/databases.png" width="75px;" height="75px;" alt="Databases"/><br /><b>Databases</b></a></td>
    <td align="center"><a href="#regex"><img src="images/regex.png" width="75ph;" height="75px;" alt="RegEx"/><br /><b>Regex</b></a></td>
    <td align="center"><a href="#system-design"><img src="images/design.png" width="110px;" height="75px;" alt="Design"/><br /><b>System Design</b></a></td>
    <td align="center"><a href="#hardware"><img src="images/hardware.png" width="110px;" height="75px;" alt="Hardware"/><br /><b>Hardware</b></a></td>
    <td align="center"><a href="#big-data"><img src="images/big-data.png" width="110px;" height="75px;" alt="Big Data"/><br /><b>Big Data</b></a></td>
  </tr>
  <tr>
    <td align="center"><a href="#certificates"><img src="images/certificates.png" width="75px;" height="75px;" alt="Certificates"/><br /><b>Certificates</b></a></td>
    <td align="center"><a href="#containers"><img src="images/containers.png" width="70px;" height="75px;" alt="Containers"/><br /><b>Containers</b></a></td>
    <td align="center"><a href="#sql"><img src="images/sql.png" width="75px;" height="75px;" alt="sql"/><br /><b>SQL</b></a></td>
    <td align="center"><a href="exercises/openshift/README.md"><img src="images/openshift.png" width="75px;" height="75px;" alt="OpenShift"/><br /><b>OpenShift</b></a></td>
    <td align="center"><a href="#storage"><img src="images/storage.png" width="75px;" height="75px;" alt="Storage"/><br /><b>Storage</b></a></td>
    <td align="center"><a href="exercises/soft_skills/README.md"><img src="images/HR.png" width="110px;" height="75px;" alt="HR"/><br /><b>Soft Skills</b></a></td>
  </tr>
  <tr>
      <td align="center"><a href="exercises/terraform/README.md"><img src="images/terraform.png" width="70px;" height="75px;" alt="Terraform"/><br /><b>Terraform</b></a></td>
      <td align="center"><a href="#mongo"><img src="images/mongo.png" width="75px;" height="75px;" alt="Mongo"/><br /><b>Mongo</b></a></td>
      <td align="center"><a href="#puppet"><img src="images/puppet.png" width="75px;" height="75px;" alt="puppet"/><br /><b>Puppet</b></a></td>
      <td align="center"><a href="#distributed"><img src="images/distributed.png" width="110px;" height="75px;" alt="Distributed"/><br /><b>Distributed</b></a></td>
      <td align="center"><a href="#questions-you-ask"><img src="images/you.png" width="90px;" height="75px;" alt="you"/><br /><b>Questions you can ask</b></a></td>
      <td align="center"><a href="exercises/perl/README.md"><img src="images/perl.png" width="75px;" height="75px;" alt="perl"/><br /><b>Perl</b></a></td>
  </tr>
</table>
</center>
<!-- markdownlint-enable -->
<!-- prettier-ignore-end -->
<!-- ALL-TOPICS-LIST:END -->

## Network

<details>
<summary>Что вам нужно для общения?</summary><br><b>

  - Общий язык (чтобы обе стороны понимали друг друга)
  - Способ обращения к тому, с кем вы хотите общаться
  - Связь (чтобы содержание сообщения могло дойти до получателей)
</b><</details

<details>
<summary>Что такое TCP/IP?</summary><br><b>

Набор протоколов, определяющих, как два или более устройств могут взаимодействовать друг с другом.
Чтобы узнать больше о TCP/IP, прочитайте статью [here](http://www.penguintutor.com/linux/basic-network-reference)
</b><</details

<details>
<summary>Что такое Ethernet?</summary><br><b>

Ethernet - это наиболее распространенный тип локальной вычислительной сети (ЛВС), используемый сегодня. Локальная сеть - в отличие от глобальной сети (WAN), которая охватывает большую географическую область - представляет собой соединенную сеть компьютеров на небольшой территории, например, в вашем офисе, студенческом городке или даже дома.
</b><</details

<details>
<summary>Что такое MAC-адрес? Для чего он используется? </summary><br><b>

MAC-адрес - это уникальный идентификационный номер или код, используемый для идентификации отдельных устройств в сети.

Пакеты, отправляемые по сети ethernet, всегда приходят с MAC-адреса и отправляются на MAC-адрес. Если сетевой адаптер получает пакет, он сравнивает MAC-адрес назначения пакета с собственным MAC-адресом адаптера.

</b><</details>>

<details>
<summary>Когда используется этот MAC-адрес?: ff:ff:ff:ff:ff:ff:ff</summary><br><b>

Когда устройство отправляет пакет на широковещательный MAC-адрес (FF:FF:FF:FF:FF:FF:FF:FF:FF), он доставляется всем станциям в локальной сети. Широковещательные передачи Ethernet используются для преобразования IP-адресов в MAC-адреса (с помощью ARP) на канальном уровне.
</b><</details>>

<details>
<summary>Что такое IP-адрес?</summary><br><b>

Адрес интернет-протокола (IP-адрес) - это числовая метка, присваиваемая каждому устройству, подключенному к компьютерной сети, которое использует интернет-протокол для связи. IP-адрес выполняет две основные функции: идентификация хоста или сетевого интерфейса и адресация местоположения.
</b><</details>>

<details>
<summary>Объяснение маски подсети и приведен пример</summary><br><b>

Маска подсети - это 32-битное число, которое маскирует IP-адрес и делит IP-адрес на сетевой адрес и адрес хоста. Маска подсети создается путем установки битов сети на все "1" и битов хоста на все "0". В пределах данной сети два адреса хостов зарезервированы для специальных целей и не могут быть назначены хостам. Адрес "0" назначается сетевому адресу, а "255" - широковещательному, и они не могут быть назначены хостам.

**Например**

```
| Класс адреса | Количество битов сети | Количество битов хоста | Маска подсети | Нотация CIDR | Маска подсети.
| ------------- | ------------------ | --------------- | --------------- | ------------- |
| A | 8 | 24 | 255.0.0.0 | /8 |
| A | 9 | 23 | 255.128.0.0 | /9 |
| A | 12 | 20 | 255.240.0.0 | /12 |
| A | 14 | 18 | 255.252.0.0 | /14 |
| B | 16 | 16 | 255.255.0.0 | /16 |
| B | 17 | 15 | 255.255.128.0 | /17 |
| B | 20 | 12 | 255.255.240.0 | /20 |
| B | 22 | 10 | 255.255.252.0 | /22 |
| C | 24 | 8 | 255.255.255.0 | /24 |
| C | 25 | 7 | 255.255.255.128 | /25 |
| C | 28 | 4 | 255.255.255.240 | /28 |
| C | 30 | 2 | 255.255.255.252 | /30 |

```
</b><</details>>

<details>
<summary>Что такое частный IP-адрес? В каких сценариях/проектах систем его следует использовать? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое публичный IP-адрес? В каких сценариях/системных конструкциях его следует использовать? </summary><br><b>
</b><</details>>

<details>
<summary>Объясните модель OSI. Какие существуют уровни? За что отвечает каждый уровень? </summary><br><b>

- Приложение: пользовательская часть (HTTP находится здесь)
- Представление: устанавливает контекст между объектами прикладного уровня (Шифрование здесь)
- Сеанс: устанавливает, управляет и завершает соединения
- Транспорт: передача последовательностей данных переменной длины от источника к узлу назначения (здесь TCP и UDP).
- Сеть: передача дейтаграмм из одной сети в другую (IP находится здесь)
- канал передачи данных: обеспечивает связь между двумя непосредственно соединенными узлами (MAC находится здесь)
- Физические: электрические и физические характеристики соединения данных (Биты находятся здесь)

Подробнее о модели OSI можно прочитать в [penguintutor.com](http://www.penguintutor.com/linux/basic-network-reference)
</b><</details>>

<details>
<summary>Для каждого из следующих уровней OSI определите, к какому уровню OSI он принадлежит:

  * Исправление ошибок
  * Маршрутизация пакетов
  * Кабели и электрические сигналы
  * MAC-адрес
  * IP-адрес
  * Прервать соединения
  * 3-стороннее рукопожатие</summary><br><b>
  * Исправление ошибок
  * Маршрутизация пакетов - Сеть
  * Кабели и электрические сигналы - Физические
  * MAC-адрес - канал передачи данных
  * IP-адрес - Сеть
  * Прервать соединение - Сеанс
  * 3-х стороннее рукопожатие - Транспорт
</b><</details>>

<details>
<summary>Какие схемы доставки вам знакомы?</summary><br><b>

Юниткаст: Общение один на один, когда есть один отправитель и один получатель.

Широковещательная передача: Отправка сообщения всем пользователям сети. Для вещания используется адрес ff:ff:ff:ff:ff:ff:ff.
           Двумя распространенными протоколами, использующими широковещание, являются ARP и DHCP.

Многоадресная рассылка: Отправка сообщения группе абонентов. Это может быть сообщение "один ко многим" или "многие ко многим".
</b><</details>>

<details>
<summary>Что такое CSMA/CD? Используется ли он в современных сетях ethernet? </summary><br><b>

CSMA/CD расшифровывается как Carrier Sense Multiple Access / Collision Detection.
Его основная задача - управление доступом к общей среде/шине, где только один узел может передавать данные в определенный момент времени.

Алгоритм CSMA/CD:

1. Перед отправкой кадра он проверяет, не передал ли уже кадр другой хост.
2. Если никто не передает, он начинает передавать кадр.
3. Если два хоста передают данные одновременно, происходит столкновение.
4. Оба хоста прекращают отправку кадра и посылают всем "сигнал застревания", уведомляя всех о том, что произошло столкновение.
5. Они ждут случайное время перед повторной отправкой
6. После того, как каждый узел подождал случайное время, он снова пытается отправить кадр и таким образом
</b><</details>>

<details>
<summary>Опишите следующие сетевые устройства и разницу между ними:

  * маршрутизатор
  * переключатель
  * концентратор</summary><br><b>
</b><</details>>

<details>
<summary>Как работает маршрутизатор?</summary><br><b>

Маршрутизатор - это физическое или виртуальное устройство, которое передает информацию между двумя или более компьютерными сетями с коммутацией пакетов. Маршрутизатор проверяет адрес назначения данного пакета данных по протоколу Интернета (IP-адрес), рассчитывает наилучший способ его доставки к месту назначения и затем пересылает его соответствующим образом.

</b><</details>>

<details>
<summary>Что такое NAT? </summary><br><b>

 Трансляция сетевых адресов (NAT) - это процесс, в котором один или несколько локальных IP-адресов переводятся в один или несколько глобальных IP-адресов и наоборот, чтобы обеспечить доступ в Интернет для локальных узлов.

</b><</details>>

<details>
<summary>Что такое прокси? Как он работает? Для чего он нам нужен? </summary><br><b>

Прокси-сервер действует как шлюз между вами и Интернетом. Это сервер-посредник, отделяющий конечных пользователей от веб-сайтов, которые они просматривают.

Если вы используете прокси-сервер, интернет-трафик проходит через прокси-сервер на пути к адресу, который вы запросили. Затем запрос возвращается обратно через тот же прокси-сервер (из этого правила есть исключения), после чего прокси-сервер пересылает вам данные, полученные от веб-сайта.

roxy-серверы обеспечивают различные уровни функциональности, безопасности и конфиденциальности в зависимости от вашего случая использования, потребностей или политики компании.
</b><</details>>

<details>
<summary>Что такое TCP? Как он работает? Что такое трехстороннее рукопожатие? </summary><br><b>

TCP 3-way handshake или трехстороннее рукопожатие - это процесс, который используется в сети TCP/IP для установления соединения между сервером и клиентом.

Трехстороннее рукопожатие в основном используется для создания соединения сокета TCP. Оно работает, когда:

- Клиентский узел посылает пакет данных SYN по IP-сети на сервер в той же или внешней сети. Цель этого пакета - узнать, открыт ли сервер для новых соединений.
- Целевой сервер должен иметь открытые порты, которые могут принимать и инициировать новые соединения. Когда сервер получает SYN-пакет от клиентского узла, он отвечает и возвращает подтверждение - ACK-пакет или SYN/ACK-пакет.
- Клиентский узел получает SYN/ACK от сервера и отвечает пакетом ACK.
</b><</details>>

<details>
<summary>Что такое round-trip delay или round-trip time? </summary><br><b>

Из [википедии](https://en.wikipedia.org/wiki/Round-trip_delay): "время, необходимое для отправки сигнала, плюс время, необходимое для получения подтверждения этого сигнала".

Бонусный вопрос: каков RTT локальной сети?
</b><</details>>

<details>
<summary>Как работает рукопожатие SSL?</summary><br><b>
</b><</details>>

<details>
<summary>В чем разница между TCP и UDP? </summary><br><b>

TCP устанавливает соединение между клиентом и сервером, чтобы гарантировать порядок пакетов, с другой стороны, UDP не устанавливает соединение между клиентом и сервером и не обрабатывает порядок пакетов. Это делает UDP более легким, чем TCP, и идеальным кандидатом для таких услуг, как потоковая передача.

[Penguintutor.com](http://www.penguintutor.com/linux/basic-network-reference) дает хорошее объяснение.
</b><</details>>

<details>
<summary>Какие протоколы TCP/IP вам знакомы? </summary><br><b>
</b><</details>>

<details>
<summary>Объяснение "шлюза по умолчанию"</summary><br><b>

Шлюз по умолчанию служит в качестве точки доступа или IP-маршрутизатора, который компьютер в сети использует для отправки информации на компьютер в другой сети или в Интернете.
</b><</details>>

<details>
<summary>Что такое ARP? Как он работает? </summary><br><b>

ARP означает протокол разрешения адресов. Когда вы пытаетесь пропинговать IP-адрес в локальной сети, скажем 192.168.1.1, ваша система должна преобразовать IP-адрес 192.168.1.1 в MAC-адрес. Для этого используется ARP для разрешения адреса, отсюда и его название.

Системы ведут таблицу поиска ARP, в которой хранится информация о том, какие IP-адреса связаны с какими MAC-адресами. При попытке отправить пакет на IP-адрес система сначала обращается к этой таблице, чтобы узнать, известен ли ей MAC-адрес. Если значение кэшировано, ARP не используется.
</b><</details>>

<details>
<summary>Что такое TTL? Что он помогает предотвратить? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое DHCP? Как он работает? </summary><br><b>

Он расшифровывается как Dynamic Host Configuration Protocol и распределяет IP-адреса, маски подсети и шлюзы между хостами. Вот как это работает:

* Хост, входящий в сеть, отправляет сообщение в поисках сервера DHCP (DHCP DISCOVER).
* Сообщение о предложении отправляется обратно DHCP-сервером в виде пакета, содержащего время аренды, маску подсети, IP-адреса и т.д. (DHCP OFFER).
* В зависимости от того, какое предложение было принято, клиент отправляет ответное широковещательное сообщение, информируя об этом все серверы DHCP (DHCP REQUEST).
* Сервер отправляет подтверждение (DHCP ACK).

Подробнее [здесь] (https://linuxjourney.com/lesson/dhcp-overview)
</b><</details>>

<details>
<summary>Можно ли иметь два DHCP-сервера в одной сети? Как это работает? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое SSL-туннелирование? Как это работает? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое сокет? Где можно посмотреть список сокетов в вашей системе? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое IPv6? Почему мы должны рассматривать возможность его использования, если у нас есть IPv4? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое VLAN? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое MTU?</summary><br><b>
</b><</details>>

<details>
<summary>Что произойдет, если вы отправите пакет, размер которого превышает MTU?</summary><br><b>
</b><</details>>

<details>
<summary>Истина или ложь? Ping использует UDP, потому что не заботится о надежном соединении</summary><br><b>.
</b><</details>>

<details>
<summary>Что такое SDN? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое ICMP? Для чего он используется? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое NAT? Как он работает? </summary><br><b>

NAT расшифровывается как трансляция сетевых адресов. Это способ сопоставления нескольких локальных частных адресов с общедоступным адресом перед передачей информации. Организации, которые хотят, чтобы несколько устройств использовали один IP-адрес, используют NAT, как и большинство домашних маршрутизаторов.
Например, частный IP-адрес вашего компьютера может быть 192.168.1.100, но ваш маршрутизатор направляет трафик на публичный IP-адрес (например, 1.1.1.1). Любое устройство в Интернете будет видеть трафик, исходящий с вашего публичного IP (1.1.1.1) вместо вашего частного IP (192.168.1.100).
</b><</details>>

<details>
<summary>Какие факторы влияют на производительность сети</summary><br><b>
</b><</details>>

<details>
<summary>Какой номер порта используется в каждом из следующих протоколов?

  * SSH
  * SMTP
  * HTTP
  * DNS
  * HTTPS
  * FTP
  * SFTP
</summary><br><b>

  * SSH - 22
  * SMTP - 25
  * HTTP - 80
  * DNS - 53
  * HTTPS - 443
  * FTP - 21
  * SFTP - 22
</b><</details>>

#### Сеть - плоскости данных и управления

<details>
<summary>Что означает "плоскость управления"? </summary><br><b>

Плоскость управления - это часть сети, которая решает, как маршрутизировать и пересылать пакеты в другое место.
</b><</details>>

<details>
<summary>Что означает "плоскость данных"? </summary><br><b>

Плоскость данных - это часть сети, которая фактически пересылает данные/пакеты.
</b><</details>>

<details>
<summary>Что означает "плоскость управления"? </summary><br><b>

Относится к функциям мониторинга и управления.
</b><</details>>

<details>
<summary>К какой плоскости (данные, управление, ...) относится создание таблиц маршрутизации?</summary><br><b>

Самолет управления.
</b><</details>>

<details>
<summary>Объяснение протокола Spanning Tree Protocol (STP)</summary><br><b>
</b><</details>>

<details>
<summary>Что такое агрегация ссылок? Зачем она используется? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое асимметричная маршрутизация? Как с этим бороться? </summary><br><b>
</b><</details>>

<details>
<summary>Какие оверлейные (туннельные) протоколы вам знакомы? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое GRE? Как он работает? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое VXLAN? Как это работает? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое SNAT? </summary><br><b>
</b><</details>>

<details>
<summary>Объяснение OSPF</summary><br><b>
</b><</details>>

<details>
<summary>Что такое латентность?</summary><br><b>
</b><</details>>

<details>
<summary>Что такое пропускная способность? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое пропускная способность? </summary><br><b>
</b><</details>>

<details>
<summary>При выполнении поискового запроса что важнее, задержка или пропускная способность? И как это обеспечить, управляя глобальной инфраструктурой? </summary><br><b>

Латентность. Чтобы иметь хорошую задержку, поисковый запрос должен быть направлен в ближайший центр обработки данных.
</b><</details>>

<details>
<summary>При загрузке видео что важнее - задержка или пропускная способность? И как это обеспечить? </summary><br><b>

Пропускная способность. Чтобы иметь хорошую пропускную способность, поток загрузки должен быть направлен на малоиспользуемый канал.
</b><</details>>

<details>
<summary>Какие еще соображения (кроме задержки и пропускной способности) существуют при пересылке запросов?</summary><br><b>

* Поддерживать кэши в актуальном состоянии (что означает, что запрос может быть перенаправлен не в ближайший центр обработки данных).
</b><</details>>

<details>
<summary>Объяснение корешка и листа</summary><br><b>
</b><</details>>

<details>
<summary>Что такое перегрузка сети? Что может ее вызвать? </summary><br><b>
</b><</details>>

<details>
<summary>Что вы можете сказать о формате пакетов UDP? Что можно сказать о формате пакетов TCP? Чем они отличаются? </summary><br><b>
</b><</details>>

<details>
<summary>Что такое алгоритм экспоненциального отката? Где он используется? </summary><br><b>
</b><</details>>

<details>
<summary>Используя код Хэмминга, каким будет кодовое слово для следующего слова данных 100111010001101?</summary><br><b>

00110011110100011101
</b><</details>>

<details>
<summary>Приведите примеры протоколов, встречающихся на прикладном уровне</summary><br><b>

* Протокол передачи гипертекста (HTTP) - используется для веб-страниц в Интернете
* Простой протокол передачи почты (SMTP) - передача электронной почты
* Телекоммуникационная сеть - (TELNET) - эмуляция терминала для обеспечения доступа клиента к серверу telnet
* Протокол передачи файлов (FTP) - облегчает передачу файлов между двумя любыми машинами.
* Система доменных имен (DNS) - перевод доменных имен
* Протокол динамической конфигурации хоста (DHCP) - распределяет IP-адреса, маски подсети и шлюзы между хостами.
* Простой протокол управления сетью (SNMP) - собирает данные об устройствах в сети
</b><</details>>

<details>
<summary>Приведите примеры протоколов, встречающихся на сетевом уровне</summary><br><b>

* Интернет-протокол (IP) - помогает в маршрутизации пакетов от одной машины к другой
* Internet Control Message Protocol (ICMP) - позволяет узнать, что происходит, например, сообщения об ошибках и отладочная информация.
</b><</details>>

<details>
<summary>Что такое HSTS?</summary><br><b>
HTTP Strict Transport Security - это директива веб-сервера, которая сообщает пользовательским агентам и веб-браузерам, как обрабатывать соединение через заголовок ответа, отправляемый в самом начале и обратно в браузер. Это заставляет устанавливать соединения через шифрование HTTPS, игнорируя любой вызов скрипта для загрузки любого ресурса в этом домене через HTTP.

Подробнее [здесь](https://www.globalsign.com/en/blog/what-is-hsts-and-how-do-i-use-it#:~:text=HTTP%20Strict%20Transport%20Security%20(HSTS,and%20back%20to%20the%20browser).
</b><</details>>

#### Сеть - Misc

<details>
<summary>Что такое Интернет? То же ли это, что и Всемирная паутина? </summary><br><b>

Интернет - это сеть сетей, передающих огромные объемы данных по всему миру.<br>
Всемирная паутина - это приложение, работающее на миллионах серверов, расположенных в Интернете, доступ к которому осуществляется через так называемый веб-браузер.
</b><</details>>

<details>
<summary>Что такое ISP? </summary><br><b>

ISP (Internet Service Provider) - это местный провайдер интернет-услуг.
</b><</details>>

## Linux

#### Приложение Linux Master

Полностью бесплатное приложение для проверки ваших знаний о Linux

<a href="https://play.google.com/store/apps</details?id=com.codingshell.linuxmaster"><img src="images/linux_master.jpeg"/></a>

### Самооценка Linux

<details>
<summary>Какой у вас опыт работы с Linux?</summary><br><b>

Только вы знаете :)

Например:
* Администрация
* Поиск и устранение неисправностей и отладка
* Хранение
* Сеть
* Развитие
* Развертывания
</b><</details>>

<details>
<summary>Объясните, что делает каждая из следующих команд, и приведите пример их использования:

  * прикосновение
  * ls
  * rm
  * кот
  * cp
  * mkdir
  * pwd
  * cd
</summary><br><b>

  * touch - обновление временной метки файла. Чаще всего используется для создания файлов
  * ls - перечисление файлов и каталогов
  * rm - удаление файлов и каталогов
  * cat - создание, просмотр и конкатенация файлов
  * cp - копирование файлов и каталогов
  * mkdir - создание каталогов
  * pwd - вывести текущий рабочий каталог (= по какому пути в данный момент находится пользователь)
  * cd - сменить каталог
</b><</details>>

<details>
<summary>Что делает каждая из следующих команд?

  * cd /
  * cd ~
  * cd
  * cd ...
  * cd .
  * cd -
</summary><br><b>

  * cd / -> перейдите в корневой каталог
  * cd ~ -> перейдите в свой домашний каталог
  * cd -> перейдите в свой домашний каталог
  * cd ... -> перейдите в каталог выше вашего текущего, т.е. родительского каталога
  * cd . -> перейдите в каталог, в котором вы сейчас находитесь
  * cd - -> переход к последнему посещенному пути
</b><</details>>

<details>
<summary>Некоторые из команд в предыдущем вопросе можно выполнить с флагом -r/-R. Что он делает? Приведите пример, когда вы могли бы его использовать</summary><br><b>

Флаг -r (или -R в некоторых командах) позволяет пользователю выполнить определенную команду рекурсивно. Например, перечисление всех файлов под следующим деревом возможно при рекурсивном выполнении (`ls -R`):

/dir1/
  dir2/
    файл1
    файл2
  dir3/
    файл3

Чтобы перечислить все файлы, можно выполнить команду `ls -R /dir1`.
</b><</details>>

<details>
<summary>Пояснение каждого поля в выводе команды `ls -l`</summary><br><b>
Он показывает подробный список файлов в длинном формате. Слева направо:

* разрешения на файлы, количество ссылок, имя владельца, группа владельцев, размер файла, метка времени последней модификации и имя каталога/файла.
</b><</details>>

<details>
<summary>Что такое скрытые файлы/каталоги? Как их перечислить? </summary><br><b>

Это файлы, которые не отображаются после выполнения стандартного прямого листинга ls. Примером таких файлов является .bashrc, который используется для выполнения некоторых скриптов. Некоторые также хранят конфигурацию служб на вашем хосте, например .KUBECONFIG. Для их перечисления используется команда `ls -a`.
</b><</details>>

<details>
<summary>Что делают > и < с точки зрения ввода и вывода для программ?</summary><br><b>
Они принимают входные данные (<) и выходные данные для данного файла (>), используя stdin и stdout.

`myProgram < input.txt > executionOutput.txt`
</b><</details>>

<details>
<summary>Объясните, что делает каждая из следующих команд, и приведите пример их использования:

  * sed
  * grep
  * разрез
  * awk
</summary><br><b>

  - sed: потоковый редактор. Может использоваться для различных целей, например, для замены слова в файле: `sed -i s/salad/burger/g`.
  - grep: инструмент поиска. Используется для поиска, подсчета или сопоставления текста в файле:
    - поиск любой строки, содержащей слово в файле: `grep 'word' file.md`.
    - или вывести общее количество раз, когда строка встречается в файле: `grep -c 'This is a string' file.md`.
  - cut: инструмент для вырезания выбранных частей каждой строки файла:
    - синтаксис: `cut OPTION [FILE]`.
      - вырезание первых двух байтов из слова в файле: `cut -b 1-2 file.md`, выход: `два`.
</b><</details>>

<details>
<summary>Как переименовать имя файла или каталога?</summary><br><b>

Использование команды `mv`.
</b><</details>>

<details>
<summary>Укажите, какую команду вы бы использовали (и как) для каждого из следующих сценариев 

  * Удалить каталог с файлами
  * Отображение содержимого файла
  * Предоставляет доступ к файлу /tmp/x для всех желающих
  * Изменить рабочий каталог на домашний каталог пользователя
  * Замените каждое вхождение слова "good" на "great" в файле /tmp/y</summary><br><b>

  - `rm -rf dir`
  - `кот или меньше`
  - `chmod 777 /tmp/x`
  - `cd ~`
  - `sed -i s/good/great/g /tmp/y`
</b><</details>>

<details>
<summary>Как можно проверить путь к определенной команде?</summary><br><b>

  * где
  * который
</b><</details>>

<details>
<summary>В чем разница между этими двумя командами? Приведут ли они к одинаковому результату?

```
эхо привет мир
эхо "hello world"
```
</summary><br><b>

Команда echo получает два отдельных аргумента при первом выполнении, а при втором - один аргумент, которым является строка "hello world". Вывод будет одинаковым.
</b><</details>>

<details>
<summary>Объяснение трубопровода. Как выполнять трубопровод? </summary><br><b>

Использование трубы в Linux позволяет отправить вывод одной команды на вход другой команды. Например: `cat /etc/services | wc -l`.
</b><</details>>

<details>
<summary>Исправьте следующие команды:

  * sed "s/1/2/g' /tmp/myFile
  * find . -iname \*.yaml -exec sed -i "s/1/2/g" {} ;
</summary><br><b>

```
sed 's/1/2/g' /tmp/myFile # sed "s/1/2/g" тоже подойдет
найти . -iname "*.yaml" -exec sed -i "s/1/2/g" {} \;
```
</b><</details>>

<details>
<summary>Как проверить, какие команды вы выполняли в прошлом?</summary><br><b>

команда history или файл .bash_history
</b><</details>>

<details>
<summary>При выполнении команды <code>df</code> вы получаете сообщение "команда не найдена". Что может быть не так и как это исправить? </summary><br><b>
</b>
<p><b>
Скорее всего, стандартный/генерируемый $PATH был каким-то образом изменен или переопределен, поэтому не содержит <code>/bin/</code>, куда обычно попадает df.
Эта проблема также может возникнуть, если bash_profile или любой конфигурационный файл вашего интерпретатора был неправильно изменен, что приведет к ошибочному поведению.
Вы можете решить эту проблему, исправив переменную $PATH:

Как исправить это, есть несколько вариантов:

1. Вручную добавить все необходимое в $PATH <code>PATH="$PATH":/user/bin:/..etc</code>.
2. У вас есть резервная копия ваших странных переменных env.
3. Найдите переменную $PATH вашего дистрибутива по умолчанию, скопируйте ее и вставьте, используя метод #1

Примечание: Существует множество способов получения подобных ошибок: если bash_profile или любой конфигурационный файл вашего интерпретатора был неправильно изменен; вызывая ошибочное поведение,
проблемы с разрешениями, плохо скомпилированное программное обеспечение (если вы скомпилировали его самостоятельно)... нет ответа, который был бы верен в 100% случаев.
</b>
</p>
<</details>>

<details>
<summary>Как периодически планировать выполнение задач?</summary><br><b>

Вы можете использовать команды <code>cron</code> и <code>at</code>.
С помощью cron задания планируются в следующем формате:

<code>*/30 * * * * * bash myscript.sh</code> Выполняет сценарий каждые 30 минут.

<минута> <час> <день месяца> <месяц> <день недели> <команда для выполнения>

Задания хранятся в cron-файле, вы можете записать их в него с помощью <code>crontab -e</code>.

Также, если вы используете дистрибутив с systemd, рекомендуется использовать таймеры systemd.
</b><</details>>

#### Linux - Перенаправление ввода/вывода

<details>
<summary>Объяснение перенаправления ввода/вывода в Linux</summary><br><b>
</b><</details>>

<details>
<summary>Демонстрирует перенаправление вывода в Linux</summary><br><b>

ls > ls_output.txt
</b><</details>>

<details>
<summary>Демонстрирует перенаправление вывода stderr в Linux</summary><br><b>

yippiekaiyay 2> ls_output.txt
</b><</details>>

<details>
<summary>Демонстрация перенаправления stderr в stdout в Linux</summary><br><b>

yippiekaiyay 1>&2 
</b><</details>>

<details>
<summary>Каков результат выполнения следующей команды? <code>yippiekaiyay 1>&2 die_hard</code></code></summary><br><b>

Вывод, похожий на: `yippikaiyay: команда не найдена...`<br>.
Файл `die_hard` не будет создан
</b><</details>>

#### Linux FHS

<details>
<summary>В Linux FHS (Filesystem Hierarchy Standard) что такое <code>/</code>? </summary><br><b>

Корень файловой системы. Начало дерева.
</b><</details>>

<details>
<summary>Что хранится в каждом из следующих путей?

  - /bin, /sbin, /usr/bin и /usr/sbin
  - /etc
  - /home
  - /var
  - /tmp</summary><br><b>

  * двоичные файлы
  * конфигурационные файлы
  * домашние каталоги различных пользователей
  * файлы, которые часто меняются и модифицируются, например, журналы.
  * временные файлы
</b><</details>>

<details>
<summary>Что особенного в каталоге /tmp по сравнению с другими каталогами?</summary><br><b>

Папка `/tmp` очищается автоматически, обычно при перезагрузке.
</b><</details>>

<details>
<summary>Какую информацию можно найти в /proc?</summary><br><b>
</b><</details>>

<details>
<summary>Чем /proc отличается от других файловых систем? </summary><br><b>
</b><</details>>

<details>
<summary>Истина или ложь? только root может создавать файлы в /proc</summary><br><b>

Ложь. Никто не может создать файл в /proc напрямую (определенные операции могут привести к созданию файлов в /proc ядром).
</b><</details>>

<details>
<summary>Что можно найти в /proc/cmdline?</summary><br><b>

Команда, передаваемая загрузчику для запуска ядра
</b><</details>>

<details>
<summary>По какому пути вы можете найти системные устройства (например, блочное хранилище)?</summary><br><b>
</b><</details>>

#### Linux - Разрешения

<details>
<summary>Как изменить права доступа к файлу?</summary><br><b>

Использование команды `chmod`.
</b><</details>>

<details>
<summary>Что означают следующие разрешения?

  * 777
  * 644
  * 750</summary><br><b>

<pre>
777 - Вы указываете владельца, группу и другое: Выполнить (1), Записать (2) и Прочитать (4); 4+2+1 = 7.
644 - Владелец имеет Чтение (4), Запись (2), 4+2 = 6; Группа и Другой имеют Чтение (4).
750 - Владелец имеет x+r+w, группа имеет Read (4) и Execute (1); 4+1 = 5. Другие не имеют никаких разрешений.
</pre>
</b><</details>>

<details>
<summary>Что делает эта команда? <code>chmod +x some_file</code></summary><br><b>
Он добавляет разрешения на выполнение ко всем наборам, т.е. пользователю, группе и другим.
</b><</details>>

<details>
<summary>Объясните, что такое setgid и setuid</summary><br><b>

* setuid - это файловое разрешение в linux, которое позволяет пользователю запускать файл или программу с разрешениями владельца этого файла. Это возможно путем повышения привилегий текущего пользователя.
* setgid - процесс при выполнении будет запускаться от имени группы, которой принадлежит файл.
</b><</details>>

<details>
<summary>Какова цель липкого бита?</summary><br><b>
Это бит, который позволяет только владельцу или пользователю root удалять или изменять файл.
</b><</details>>

<details>
<summary>Что делают следующие команды?

  - chmod
  - chown
  - chgrp</summary><br><b>

  * chmod - изменяет разрешения доступа к объектам файловой системы.
  * chown - изменение владельца файлов и каталогов файловой системы
  * chgrp - изменение группы, связанной с объектом файловой системы
</b><</details>>

<details>
<summary>Что такое sudo? Как его настроить? </summary><br><b>
</b><</details>>

<details>
<summary>Правда или ложь? Для установки пакетов в систему необходимо быть пользователем root или использовать команду sudo</summary><br><b>

Правда
</b><</details>>

<details>
<summary>Объясните, что такое ACL. Для каких случаев вы рекомендуете их использовать? </summary><br><b>
</b><</details>>

<details>
<summary>Вы пытаетесь создать файл, но это не удается. Назовите не менее трех причин, по которым это может произойти</summary><br><b>

* Не нужно больше места на диске
* Больше нет инодов
* Нет разрешений
</b><</details>

<details>
<summary>Пользователь случайно выполнил следующее <code>chmod -x $(which chmod)</code>. Как это исправить? </summary><br><b>
</b><</details>

#### Linux - systemd

<details>
<summary>Что такое systemd? </summary><br>
<b>
Systemd - это демон (System 'd', d означает daemon).

Демон - это программа, которая работает в фоновом режиме без прямого контроля со стороны пользователя, хотя пользователь может в любое время
поговорите с демоном.

systemd имеет множество функций, таких как контроль/отслеживание пользовательских процессов, поддержка моментальных снимков, блокировка ингибиторов...

Если представить систему unix/linux в виде слоев, то systemd будет располагаться сразу после ядра linux.<br>
Hardware -> Kernel -> <u>Daemons</u>, System Libraries, Server Display.
</b>
<</details>

<details>
<summary>Как запустить или остановить службу?</summary><br><b>

Чтобы запустить службу: `systemctl start <имя службы>`.
Чтобы остановить службу: `systemctl stop <имя службы>`.
</b><</details>

<details>
<summary>Как проверить статус службы?</summary><br><b>

`systemctl status <имя службы>`
</b><</details>

<details>
<summary>В системе, использующей systemd, как бы вы отобразили журналы? </summary><br><b>

<code>journalctl</code>
</b><</details>

<details>
<summary>Описание того, как сделать определенный процесс/приложение сервисом</summary><br><b>
</b><</details>

##### Linux - Поиск и устранение неисправностей и отладка

<details>
<summary>Где находятся системные журналы?</summary><br><b>

/var/log
</b><</details>

<details>
<summary>Как следить за содержимым файла в процессе его добавления, не открывая файл каждый раз?</summary><br><b>

tail -f <имя_файла>
</b><</details>

<details>
<summary>Что вы используете для поиска неисправностей и отладки <b>сетевых</b> проблем?</summary><br><b>

<code>dstat -t</code> отлично подходит для выявления сетевых и дисковых проблем.
<code>netstat -tnlaup</code> можно использовать для просмотра того, какие процессы запущены на каких портах.
<code>lsof -i -P</code> можно использовать для той же цели, что и netstat.
<code>ngrep -d any metafilter</code> для сопоставления regex с полезной нагрузкой пакетов.
<code>tcpdump</code> для захвата пакетов
<code>wireshark</code> та же концепция, что и tcpdump, но с графическим интерфейсом (опционально).
</b><</details>

<details>
<summary>Что вы используете для поиска и отладки <b>проблем с дисками и файловой системой</b>? </summary><br><b>

<code>dstat -t</code> отлично подходит для выявления сетевых и дисковых проблем.
<code>opensnoop</code> можно использовать для просмотра того, какие файлы открываются в системе (в реальном времени).
</b><</details>

<details>
<summary>Что вы используете для поиска неисправностей и отладки <b>процесса</b>? </summary><br><b>

<code>strace</code> отлично подходит для понимания того, что делает ваша программа. Он печатает каждый системный вызов, выполненный вашей программой.
</b><</details>

<details>
<summary>Что вы используете для отладки проблем, связанных с процессором? </summary><br><b>

<code>top</code> покажет вам, сколько процентов процессора потребляет каждый процесс
<code>perf</code> - отличный выбор для профайлера выборок и вообще для выяснения того, на что "тратятся" циклы вашего процессора.
<code>flamegraphs</code> отлично подходит для визуализации потребления процессора (http://www.brendangregg.com/flamegraphs.html).
</b><</details>

<details>
<summary>Вам звонит человек и утверждает, что "моя система работает медленно". Что вы делаете? </summary><br><b>

* Проверьте `top` на наличие чего-либо необычного
* Запустите `dstat -t`, чтобы проверить, связано ли это с диском или сетью.
* Проверьте, не связано ли это с сетью с помощью `sar`.
* Проверьте статистику ввода-вывода с помощью `iostat`.
</b><</details>

<details>
<summary>Объяснение вывода iostat</summary><br><b>
</b><</details>

<details>
<summary>Как отлаживать двоичные файлы?</summary><br><b>
</b><</details>

<details>
<summary>В чем разница между загрузкой и использованием процессора? </summary><br><b>
</b><</details>

<details>
<summary>Как измерить время выполнения программы?</summary><br><b>
</b><</details>

#### Linux - ядро

<details>
<summary>Что такое ядро, и что оно делает?</summary><br><b>

Ядро является частью операционной системы и отвечает за такие задачи, как:

  * Выделение памяти
  * Планирование процессов
  * Процессор управления
</b><</details>

<details>
<summary>Как узнать, какую версию ядра использует ваша система?</summary><br><b>

Команда `uname -a`
</b><</details>

<details>
<summary>Что такое модуль ядра Linux и как загрузить новый модуль?</summary><br><b>
</b><</details>

<details>
<summary>Объяснение пространства пользователя и пространства ядра</summary><br><b>

Операционная система выполняет ядро в защищенной памяти, чтобы никто не мог внести изменения (и создать риск сбоя). Это то, что известно как "пространство ядра".
"Пользовательское пространство" - это место, где пользователи выполняют свои команды или приложения. Важно создать такое разделение, поскольку мы не можем полагаться на то, что пользовательские приложения не будут вмешиваться в работу ядра, вызывая его сбои.

Приложения могут получить доступ к системным ресурсам и косвенно к пространству ядра, выполняя так называемые "системные вызовы".
</b><</details>

<details>
<summary>На каких этапах жизненного цикла ядра вы можете изменить его конфигурацию?</summary><br><b>

  * Время сборки (когда компилируется)
  * Время загрузки (когда он запускается)
  * Время выполнения (когда он уже запущен)
</b><</details>

<details>
<summary>Где вы можете найти конфигурацию ядра?</summary><br><b>

Обычно он находится в папке `/boot/config-<версия ядра>.<os release>.<arch>`.
</b><</details>

<details>
<summary>Где можно найти файл, содержащий команду, переданную загрузчику для запуска ядра?</summary><br><b>

`/proc/cmdline`
</b><</details>

<details>
<summary>Как перечислить параметры времени выполнения ядра?</summary><br><b>

`sysctl -a`
</b><</details>

<details>
<summary>Выполнение <code>sysctl -a</code> в качестве обычного пользователя и root приводит к разным результатам? </summary><br><b>

Да, вы можете заметить, что в большинстве систем при выполнении команды `systctl -a` от имени root вы получите больше параметров времени выполнения по сравнению с выполнением той же команды от обычного пользователя.
</b><</details>

<details>
<summary>Вы хотите включить переадресацию IPv4 в ядре, как вы это сделаете? </summary><br><b>

`sudo sysctl net.ipv4.ip_forward=1`

Чтобы сделать его постоянным (применяемым, например, после перезагрузки): вставьте `net.ipv4.ip_forward = 1` в `/etc/sysctl.conf`.

Другой способ - выполнить команду `echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward`.
</b><</details>

<details>
<summary>Как <code>sysctl</code> применяет изменения к параметрам времени выполнения ядра в момент выполнения команды sysctl?</summary><br><b>

Если вы `strace` команду sysctl, то увидите, что она делает это, изменяя файл в /proc/sys/...

Раньше это делалось с помощью системного вызова sysctl, но в какой-то момент он был устаревшим.
</b><</details>

<details>
<summary>Как сохраняются изменения параметров времени выполнения ядра? (например, применяются даже после перезагрузки системы)</summary><br><b>

Существует служба `systemd-sysctl`, которая берет содержимое /etc/sysctl.conf и применяет его. Вот как изменения сохраняются даже после перезагрузки, если они записаны в /etc/sysctl.conf
</b><</details>

<details>
<summary>Влияют ли изменения, которые вы вносите в параметры ядра контейнера, на параметры ядра хоста, на котором запущен контейнер? </summary><br><b>

Нет. Контейнеры имеют собственную файловую систему /proc, поэтому любые изменения параметров ядра внутри контейнера не влияют на хост или другие контейнеры, запущенные на этом хосте.
</b><</details>

#### Linux - SSH

<details>
<summary>Что такое SSH? Как проверить, работает ли на Linux-сервере SSH? </summary><br><b>

[Определение Википедии](https://en.wikipedia.org/wiki/SSH_(Secure_Shell)): "SSH или Secure Shell - это криптографический сетевой протокол для безопасной работы с сетевыми службами через незащищенную сеть".

[Hostinger.com Definition](https://www.hostinger.com/tutorials/ssh-tutorial-how-does-ssh-work): "SSH, или Secure Shell, - это протокол удаленного администрирования, который позволяет пользователям контролировать и изменять свои удаленные серверы через Интернет."

На сервере SSH будет запущен демон SSH. В зависимости от дистрибутива, вы должны иметь возможность проверить, запущена ли служба (например, systemctl status sshd).
</b><</details>

<details>
<summary>Почему SSH считается лучше, чем telnet?</summary><br><b>

Telnet также позволяет подключиться к удаленному узлу, но в отличие от SSH, где связь шифруется, в telnet данные передаются открытым текстом, поэтому он не считается защищенным, так как любой человек в сети может увидеть, что именно передается, включая пароли.
</b><</details>

<details>
<summary>Что хранится в <code>~/.ssh/known_hosts</code>? </summary><br><b>
</b><</details>

<details>
<summary>Вы пытаетесь подключиться к серверу по ssh и получаете сообщение "Host key verification failed". Что это значит? </summary><br><b>

Это означает, что ключ удаленного хоста был изменен и не совпадает с тем, который хранится на машине (в ~/.ssh/known_hosts).
</b><</details>

<details>
<summary>В чем разница между SSH и SSL? </summary><br><b>
</b><</details>

<details>
<summary>Для чего используется <code>ssh-keygen</code>? </summary><br><b>
</b><</details>

<details>
<summary>Что такое перенаправление портов SSH? </summary><br><b>
</b><</details>

#### Linux - Globbing, Wildcards

<details>
<summary>Что такое Globbing? </summary><br><b>
</b><</details>

<details>
<summary>Что такое подстановочные знаки? Можете ли вы привести пример их использования? </summary><br><b>
</b><</details>

<details>
<summary>Объясните, что будет соответствовать <code>ls [XYZ]</code></summary><br><b>
</b><</details>

<details>
<summary>Объясните, что будет соответствовать <code>ls [^XYZ]</code></summary><br><b>
</b><</details>

<details>
<summary>Объясните, что будет соответствовать <code>ls [0-5]</code></summary><br><b>
</b><</details>

<details>
<summary>Каждое из следующих соответствий

  - ?
  - *</summary><br><b>

  * Символ ? соответствует любому одиночному символу
  * * соответствует нулю или более символов
</b><</details>

<details>
<summary>Что мы ищем в каждой из следующих команд?

  * <code>grep '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}' some_file</code>
  * <code>grep -E "error|failure" some_file</code>
  * <code>grep '[0-9]$' some_file</code>
</summary><br><b>

1. IP-адрес
2. Слово "ошибка" или "неудача"
3. Строки, которые заканчиваются цифрой
</b><</details>

<details>
<summary>Какие номера строк будут выведены при выполнении команды `grep '\baaa\b'` на следующем содержимом:

aaa
bbb
ccc.aaa
aaaaaa</summary><br><b>

линии 1 и 3.
</b><</details>

<details>
<summary>Чем отличаются одинарные и двойные кавычки?</summary><br><b>
</b><</details>

<details>
<summary>Что такое экранирование? Какой символ используется для экранирования? </summary><br><b>
</b><</details>

<details>
<summary>Что такое код выхода? С какими кодами выхода вы знакомы? </summary><br><b>

Код выхода (или код возврата) представляет собой код, возвращаемый дочерним процессом в его
родительский процесс.

0 - это код выхода, который означает успех, а все, что выше 1, означает ошибку.
Каждый номер имеет свое значение, основанное на том, как было разработано приложение.

Я считаю это хорошей статьей в блоге, чтобы прочитать больше об этом: https://shapeshed.com/unix-exit-codes
</b><</details>

#### Процесс загрузки Linux

<details>
<summary>Расскажите мне все, что вы знаете о процессе загрузки Linux</summary><br><b>

Другой способ задать этот вопрос: что происходит с момента включения сервера до появления запроса
</b><</details>

<details>
<summary>Что такое GRUB2? </summary><br><b>
</b><</details>

<details>
<summary>Что такое Secure Boot? </summary><br><b>
</b><</details>

<details>
<summary>Что вы можете найти в /boot?</summary><br><b>
</b><</details>

##### Linux Disk & Filesystem

<details>
<summary>Что такое inode? </summary><br><b>

Для каждого файла (и каталога) в Linux существует inode - структура данных, хранящая метаданные.
связанные с файлом, такие как его размер, владелец, разрешения и т.д.
</b><</details>

<details>
<summary>Какой из следующих элементов не включен в inode:

  * Количество ссылок
  * Размер файла
  * Имя файла
  * метка времени файла</summary><br><b>

Имя файла (является частью файла каталога)
</b><</details>

<details>
<summary>Как проверить, какие диски смонтированы в данный момент? </summary><br><b>

Запустите `mount`.
</b><</details>

<details>
<summary>Вы выполняете команду <code>mount</code>, но не получаете никакого результата. Как проверить, какие монтирования есть в вашей системе? </summary><br><b>

`cat /proc/mounts`
</b><</details>

<details>
<summary>Чем отличается мягкая ссылка от жесткой ссылки?</summary><br><b>

Жесткая ссылка - это тот же файл, использующий тот же inode.
Мягкая ссылка - это ярлык на другой файл, использующий другой инод.
</b><</details>

<details>
<summary>Правда или ложь? Вы можете создать жесткую ссылку для каталога</summary><br><b>

Ложь
</b><</details>

<details>
<summary>Правда или ложь? Вы можете создать мягкую связь между различными файловыми системами</summary><br><b>

Правда
</b><</details>

<details>
<summary>Правда или ложь? В каталогах всегда есть минимум 2 ссылки</summary><br><b>

Правда.
</b><</details>

<details>
<summary>Что происходит при удалении исходного файла в случае мягкой ссылки и жесткой ссылки?</summary><br><b>
</b><</details>

<details>
<summary>Вы можете проверить, какой тип файловой системы используется в /home?</summary><br><b>

Существует множество ответов на этот вопрос. Одним из способов является выполнение команды `df -T`
</b><</details>

<details>
<summary>Что такое раздел подкачки? Для чего он используется? </summary><br><b>
</b><</details>

<details>
<summary>Как создать

  * новый пустой файл
  * файл с текстом (без использования текстового редактора)
  * файл с заданным размером</summary><br><b>
</b><</details>

<details>
<summary>Вы пытаетесь создать новый файл, но получаете сообщение "File system is full". Вы проверяете с помощью df свободное пространство и видите, что использовали только 20% пространства. В чем может быть проблема? </summary><br><b>
</b><</details>

<details>
<summary>Как проверить размер определенного каталога?</summary><br><b>

`du -sh`
</b><</details>

<details>
<summary>Что такое LVM?</summary><br><b>
</b><</details>

<details>
<summary>Объясните следующее в отношении LVM:

  * PV
  * VG
  * LV</summary><br><b>


</b><</details>

<details>
<summary>Что такое NFS? Для чего она используется? </summary><br><b>
</b><</details>

<details>
<summary>Для чего используется RAID? Можете ли вы объяснить разницу между RAID 0, 1, 5 и 10? </summary><br><b>
</b><</details>

<details>
<summary>Описание процесса расширения дискового пространства файловой системы</summary><br><b>
</b><</details>

<details>
<summary>Что такое lazy umount? </summary><br><b>
</b><</details>

<details>
<summary>Что такое tmpfs? </summary><br><b>
</b><</details>

<details>
<summary>Что хранится в каждом из следующих журналов?

  * /var/log/messages
  * /var/log/boot.log</summary><br><b>
</b><</details>

<details>
<summary>Истина или ложь? и /tmp и /var/tmp очищаются при загрузке системы</summary><br><b>

Ложь. /tmp очищается при загрузке системы, а /var/tmp очищается раз в несколько дней или не очищается вообще (зависит от дистрибутива).
</b><</details>

#### Анализ производительности Linux

<details>
<summary>Как проверить, какова средняя текущая нагрузка? </summary><br><b>

Можно использовать `uptime` или `top`.
</b><</details>

<details>
<summary>Вы знаете, как посмотреть среднее значение нагрузки, отлично. но что означает каждая его часть? например, 1.43, 2.34, 2.78</summary><br><b>

[Эта статья] (http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html) отлично подытоживает тему средней нагрузки.
</b><</details>

<details>
<summary>Как проверить использование процесса?</summary><br><b>

pidstat
</b><</details>

<details>
<summary>Как проверить дисковый ввод-вывод?</summary><br><b>

`iostat -xz 1`
</b><</details>

<details>
<summary>Как проверить, сколько свободной памяти есть в системе? Как проверить потребление памяти каждым процессом? </summary><br><b>

Вы можете использовать команды <code>top</code> и <code>free</code>.
</b><</details>

<details>
<summary>Как проверить статистику TCP? </summary><br><b>

sar -n TCP,ETCP 1
</b><</details>

#### Процессы Linux

<details>
<summary>как перечислить все процессы, запущенные в вашей системе?</summary><br><b>

`ps -ef`
</b><</details>

<details>
<summary>Как запустить процесс в фоновом режиме и зачем это вообще делать?</summary><br><b>

Этого можно добиться, указав & в конце команды.
Почему, поскольку некоторые команды/процессы могут занимать много времени для завершения
или выполняться вечно, вы можете захотеть запустить их в фоновом режиме вместо того, чтобы ждать их завершения, прежде чем снова получить контроль в текущем сеансе.
</b><</details>

<details>
<summary>Как узнать, сколько памяти потребляет определенный процесс?</summary><br><b>
<code>
mem()
{ 
    ps -eo rss,pid,euser,args:100 --sort %mem | grep -v grep | grep -i $@ | awk '{printf $1/1024 "MB"; $1=""; print }''
}
</code>
[Источник](https://stackoverflow.com/questions/3853655/in-linux-how-to-tell-how-much-memory-processes-are-using)
</b><</details>

<details>
<summary>Какой сигнал используется по умолчанию, когда вы выполняете 'kill *process id*'?</summary><br><b>
<pre>
Сигналом по умолчанию является SIGTERM (15). Этот сигнал уничтожает
процесс изящно, что означает, что он позволяет сохранить текущий
конфигурация состояния.
</pre>
</b><</details>

<details>
<summary>Какие сигналы вам знакомы?</summary><br><b>

SIGTERM - сигнал по умолчанию для завершения процесса
SIGHUP - обычно используется для перезагрузки конфигурации
SIGKILL - сигнал, который не может быть пойман или проигнорирован

Чтобы просмотреть все доступные сигналы, выполните команду `kill -l`.
</b><</details>

<details>
<summary>Что делает <code>kill 0</code>? </summary><br><b>
</b><</details>

<details>
<summary>Что делает <code>kill -0 <PID></code>? </summary><br><b>
</b><</details>

<details>
<summary>Что такое ловушка?</summary><br><b>
</b><</details>

<details>
<summary>Каждые несколько дней определенный процесс перестает выполняться. Как вы можете выяснить, почему это происходит? </summary><br><b>
</b><</details>

<details>
<summary>Что происходит, когда вы нажимаете ctrl + c?</summary><br><b>
</b><</details>

<details>
<summary>Что такое демон в Linux?</summary><br><b>

Фоновый процесс. Большинство этих процессов ожидают выполнения запросов или набора условий, прежде чем начать работу.
Некоторые примеры: sshd, crond, rpcbind.
</b><</details>

<details>
<summary>Каковы возможные состояния процесса в Linux?</summary><br><b>
<pre>
Бег (R)
Непрерывный сон (D) - процесс ожидает ввода/вывода.
Прерывистый сон (S)
Остановлен (T)
Мертвые (x)
Зомби (z)
</pre>
</b><</details>

<details>
<summary>Как убить процесс в состоянии D?</summary><br><b>
</b><</details>

<details>
<summary>Что такое зомби-процесс?</summary><br><b>

Процесс, который завершил выполнение, но не вышел из него.

Одна из причин, по которой это происходит, - неправильное программирование родительского процесса. Каждый родительский процесс должен выполнить wait(), чтобы получить код завершения от дочернего процесса, который завершил выполнение. Но когда родительский процесс не проверяет код завершения дочернего процесса, дочерний процесс может продолжать существовать, хотя он завершил выполнение.
</b><</details>

<details>
<summary>Как избавиться от зомби-процессов?</summary><br><b>

Вы не можете убить зомби-процесс обычным способом, например, с помощью `kill -9`, поскольку он уже мертв.

Один из способов уничтожить зомби-процесс - послать SIGCHLD родительскому процессу, чтобы он завершил свои дочерние процессы. Это может не сработать, если родительский процесс не был запрограммирован должным образом. Вызов выглядит так: `kill -s SIGCHLD [parent_pid]`.

Вы также можете попробовать закрыть/прервать родительский процесс. Это сделает зомби-процесс дочерним init (1), который выполняет периодическую очистку и в какой-то момент очистит зомби-процесс.
</b><</details>

<details>
<summary>Как найти все

  * Процессы, выполняемые/принадлежащие определенному пользователю
  * Процессы, которые являются Java-процессами
  * Зомби-процессы
</summary><br><b>

Если вы в какой-то момент упомянули команду ps с аргументами, ознакомьтесь с тем, что именно делают эти аргументы.
</b><</details>

<details>
<summary>Что такое процесс инициации? </summary><br><b>
Это первый процесс, выполняемый ядром при загрузке системы. Это процесс-демон, который выполняется до выключения системы. Поэтому он является родителем всех процессов.
</b><</details>

<details>
<summary>Можете ли вы описать, как создаются процессы? </summary><br><b>
</b><</details>

<details>
<summary>Как изменить приоритет процесса? Зачем вам это нужно? </summary><br><b>
</b><</details>

<details>
<summary>Вы можете объяснить, как устанавливается сетевой процесс/соединение и как оно завершается?></summary><br></b>.
</b><</details>

<details>
<summary>Что делает <code>strace</code>? А что насчет <code>ltrace</code>? </summary><br><b>
</b><</details>

<details>
<summary>Найдите все файлы, которые заканчиваются на '.yml' и замените число 1 на 2 в каждом файле</summary><br><b>

find /some_dir -iname \*.yml -print0 | xargs -0 -r sed -i "s/1/2/g"
</b><</details>

<details>
<summary>Вы запускаете ls и получаете "/lib/ld-linux-armhf.so.3 no such file or directory". В чем проблема? </summary><br><b>

Исполняемый файл ls создан для несовместимой архитектуры.
</b><</details>

<details>
<summary>Как разделить файл длиной 50 строк на 2 файла по 25 строк каждый?</summary><br><b>

Вы можете использовать команду <code>split</code> следующим образом: <code>split -l 25 some_file</code>.
</b><</details>

<details>
<summary>Что такое дескриптор файла? С какими файловыми дескрипторами вы знакомы? </summary><br><b>
Kerberos
Дескриптор файла, также известный как обработчик файла, - это уникальный номер, который идентифицирует открытый файл в операционной системе.

В Linux (и Unix) первыми тремя файловыми дескрипторами являются:

  * 0 - поток данных по умолчанию для ввода
  * 1 - поток данных по умолчанию для вывода
  * 2 - поток данных по умолчанию для вывода данных, связанных с ошибками

Это отличная статья по теме: https://www.computerhope.com/jargon/f/file-descriptor.htm.
</b><</details>

<details>
<summary>Что такое NTP? Для чего он используется? </summary><br><b>
</b><</details>

<details>
<summary>Объяснение OOM ядра</summary><br><b>
</b><</details>

##### Безопасность Linux

<details>
<summary>Что такое chroot? В каких сценариях вы могли бы использовать его? </summary><br><b>
</b><</details>

<details>
<summary>Что такое SELiunx? </summary><br><b>
</b><</details>

<details>
<summary>Что такое Kerberos?</summary><br><b>
</b><</details>

<details>
<summary>Что такое nftables? </summary><br><b>
</b><</details>

<details>
<summary>За что отвечает демон firewalld? </summary><br><b>
</b><</details>

<details>
<summary>У вас есть опыт в укреплении серверов? Можете ли вы описать процесс? </summary><br><b>
</b><</details>

##### Linux - сетевые технологии

<details>
<summary>Как перечислить все интерфейсы?</summary><br><b>

```
ip link show
```
</b><</details>

<details>
<summary>Что такое интерфейс loopback (lo)? </summary><br><b>

Интерфейс loopback - это специальный виртуальный сетевой интерфейс, который компьютер использует для связи с самим собой. Он используется в основном для диагностики и устранения неполадок, а также для подключения к серверам, работающим на локальной машине.
</b><</details>

<details>
<summary>Для чего используются следующие команды?

  * ip addr
  * ip route
  * ip-ссылка
  * пинг
  * netstat
  * traceroute</summary><br><b>
</b><</details>

<details>
<summary>Что такое сетевое пространство имен? Для чего оно используется? </summary><br><b>
</b><</details>

<details>
<summary>Как проверить, используется ли определенный порт? </summary><br><b>

Подойдет один из следующих вариантов:

```
netstat -tnlp | grep <номер_порта>
lsof -i -n -P | grep <номер_порта>
```
</b><</details>

<details>
<summary>Как превратить ваш Linux-сервер в маршрутизатор?</summary><br><b>
</b><</details>

<details>
<summary>Что такое виртуальный IP? В какой ситуации вы могли бы его использовать? </summary><br><b>
</b><</details>

<details>
<summary>Правда или ложь? MAC-адрес интерфейса назначается/устанавливается ОС</summary><br><b>

Ложь
</b><</details>

<details>
<summary>Можно ли иметь более одного шлюза по умолчанию в данной системе?</summary><br><b>

Технически, да.
</b><</details>

<details>
<summary>Что такое telnet и почему это плохая идея использовать его в производстве? (или вообще) </summary><br><b>

Telnet - это тип протокола клиент-сервер, который можно использовать для открытия командной строки на удаленном компьютере, обычно сервере.
По умолчанию все данные, отправленные и полученные через telnet, передаются в виде открытого/простого текста, поэтому его не следует использовать, так как он не шифрует данные между клиентом и сервером.
</b><</details>

<details>
<summary>Что такое таблица маршрутизации? Как ее просмотреть? </summary><br><b>
</b><</details>

<details>
<summary>Как можно отправить HTTP-запрос из оболочки? </summary><br><b>
<br>
Использование nc - это один из способов<br>.
</b><</details>

<details>
<summary>Что такое пакетные снифферы? Использовали ли вы их в прошлом? Если да, то какие снифферы пакетов вы использовали и с какой целью? </summary><br><b>
Это сетевая утилита, которая анализирует и может внедрять задачи в поток данных, проходящий по целевой сети.
</b><</details>

<details>
<summary>Как составить список активных соединений?</summary><br><b>
</b><</details>

<details>
<summary>Как запустить обнаружение соседей в IPv6?</summary><br><b>

Один из способов - `ping6 ff02::1`.
</b><</details>

<details>
<summary>Что такое связывание сетевых интерфейсов и знаете ли вы, как оно выполняется в Linux?</summary><br><b>
</b><</details>

<details>
<summary>Какие существуют режимы объединения сетей?</summary><br><b>

Есть несколько режимов:

  * balance-rr: round robing bonding
  * активное резервное копирование: режим отказоустойчивости, в котором активен только один из них
  * balance-tlb: Адаптивная балансировка нагрузки при передаче
  * balance-alb: Адаптивная балансировка нагрузки
</b><</details>

<details>
<summary>Что такое мост? Как он добавляется в Linux OS? </summary><br><b>
</b><</details>

##### Linux - DNS

<details>
<summary>Как проверить, каково имя хоста системы?</summary><br><b>

`cat /etc/hostname`

Вы также можете запустить `hostnamectl` или `hostname`, но это может вывести только временное имя хоста. Постоянным будет то, которое находится в файле.
</b><</details>

<details>
<summary>Для чего используется файл <code>/etc/resolv.conf</code>? Что он включает в себя? </summary><br><b>
</b><</details>

<details>
<summary>Какие команды вы используете для выполнения DNS-запросов (или устранения проблем, связанных с DNS)?</summary><br><b>

Вы можете указать одно или несколько из следующего:

 * <code>dig</code>
 * <code>host</code>
 * <code>nslookup</code>
</b><</details>

<details>
<summary>Вы запускаете <code>dig codingshell.com</code> и получаете следующий результат: 

```
РАЗДЕЛ ОТВЕТОВ:
				codingshell.com.3515INA				185.199.109.153
```

Каково значение числа 3515?
</summary><br><b>

Это и есть TTL. Когда вы ищете адрес по имени домена/хоста, ваша ОС выполняет разрешение DNS, обращаясь к серверам имен DNS для получения IP-адреса искомого хоста/домена.<br>
Когда вы получаете ответ, этот ответ кэшируется в вашей ОС на определенный период времени. Этот период времени также известен как TTL, и в этом смысл числа 3515 - ответ будет кэшироваться в течение 3515 секунд, прежде чем будет удален из кэша, и в течение этого периода времени вы получите значение из кэша вместо того, чтобы снова запрашивать адрес у серверов имен DNS.
</b><</details>

##### Linux - Упаковка

<details>
<summary>У вас есть опыт работы с упаковкой? (в смысле создания пакетов) Можете ли вы объяснить, как это работает? </summary><br><b>
</b><</details>

<details>
<summary>Как выполняется установка/удаление пакетов в используемом вами дистрибутиве?</summary><br><b>

Ответ зависит от используемого дистрибутива.

В Fedora/CentOS/RHEL/Rocky это можно сделать с помощью команд `rpm` или `dnf`.
В Ubuntu это можно сделать с помощью команды `apt`.
</b><</details>

<details>
<summary>РПМ: объясните формат спецификации (что она должна и может включать)</summary><br><b>
</b><</details>

<details>
<summary>Как перечислить содержимое пакета без его фактической установки?</summary><br><b>
</b><</details>

<details>
<summary>Как узнать, к какому пакету принадлежит файл в системе? Является ли проблемой, если он не принадлежит ни к одному пакету? </summary><br><b>
</b><</details>

<details>
<summary>Где хранятся репозитории? (в зависимости от используемого дистрибутива)</summary><br><b>
</b><</details>

<details>
<summary>Что такое архив? Как его создать в Linux? </summary><br><b>
</b><</details>

<details>
<summary>Как извлечь содержимое архива?</summary><br><b>
</b><</details>

<details>
<summary>Зачем нам нужны менеджеры пакетов? Почему бы просто не создавать архивы и публиковать их? </summary><br><b>

Менеджеры пакетов позволяют вам управлять жизненным циклом пакетов, например, устанавливать, удалять и обновлять пакеты.<br>
Кроме того, в спецификации можно указать, как будет установлен определенный пакет - куда скопировать файлы, какие команды выполнить до установки, после установки и т.д.
</b><</details>

#### Linux DNF

<details>
<summary>Что такое ДНФ? </summary><br><b>

Из [repo](https://github.com/rpm-software-management/dnf):

"Dandified YUM (DNF) - это следующая предстоящая основная версия YUM. Она осуществляет управление пакетами с использованием библиотек RPM, libsolv и hawkey."

Официальный [docs](https://dnf.readthedocs.io/en/latest/)

</b><</details>

<details>
<summary>Как найти пакет, который предоставляет команду /usr/bin/git? (пакет не обязательно установлен)</summary><br><b>

dnf предоставляет /usr/bin/git
</b><</details>

##### Приложения и службы Linux

<details>
<summary>Что вы можете найти в /etc/services? </summary><br><b>
</b><</details>

<details>
<summary>Как сделать так, чтобы служба автоматически запускалась после перезагрузки или сбоя?</summary><br><b>

Зависит от системы init.

Systemd: <code> systemctl enable [service_name] </code>
Система V: <code> update-rc.d [service_name] </code> и добавьте эту строку <code> id:5678:respawn:/bin/sh /path/to/app </code> в /etc/inittab
Upstart: добавить скрипт инициации Upstart в /etc/init/service.conf
</b><</details>

<details>
<summary>Вы запускаете <code>ssh 127.0.0.1</code>, но он терпит неудачу с сообщением "connection refused". В чем может быть проблема? </summary><br><b>

1. SSH-сервер не установлен
2. SSH-сервер не запущен
</b><</details>

<details>
<summary>Как вывести общие библиотеки, необходимые определенной программе? Для чего это нужно? </summary><br><b>
</b><</details>

<details>
<summary>Что такое CUPS? </summary><br><b>
</b><</details>

<details>
<summary>С какими типами веб-серверов вы знакомы? </summary><br><b>

Nginx, Apache httpd.
</b><</details>

##### Пользователи и группы Linux

<details>
<summary>Что такое "суперпользователь" (или пользователь root)? Чем он отличается от обычных пользователей? </summary><br><b>
</b><</details>

<details>
<summary>Как создавать пользователей? Где хранится информация о пользователях?</summary><br>

Команда для создания пользователей - `useradd`. 

Синтаксис:
`useradd [options] Имя пользователя`

Существует 2 конфигурационных файла, в которых хранится информация о пользователях

1. `/etc/passwd` - В этом файле хранится информация о пользователях, например, имя пользователя, оболочка и т.д. 

2. `/etc/shadow` - пароль пользователя хранится в зашифрованном виде 
<</details>

<details>
<summary>В каком файле хранится информация о группах?</summary><br>

В файле `/etc/groups` хранится имя группы, ID группы, имена пользователей, которые входят во вторичную группу.
<</details>

<details>
<summary>Как изменить/установить пароль пользователя?</summary><br>

`passwd <имя пользователя>` - это команда для установки/изменения пароля пользователя.
<</details>

<details>
<summary>В каком файле хранятся пароли пользователей? Виден ли он всем? </summary><br>

Файл `/etc/shadow` хранит пароли пользователей в зашифрованном виде. НЕТ, он доступен только пользователю `root`.
<</details>

<details>
<summary>Вы знаете, как создать нового пользователя без использования команды adduser/useradd? </summary><br>

ДА, мы можем создать нового пользователя, вручную добавив запись в файл `/etc/passwd`. 

Например, если нам нужно создать пользователя по имени `john`. 

Шаг 1: Добавьте запись в файл `/etc/passwd`, чтобы пользователь был создан.

`echo "john:x:2001:2001::/home/john:/bin/bash" >> /etc/passwd` 

Шаг 2: Добавьте запись в файл `/etc/group`, потому что каждый пользователь принадлежит к основной группе, которая имеет то же имя, что и имя пользователя.

`echo "john:x:2001:" >> /etc/group`

Шаг 3: Проверьте, был ли создан пользователь

`id john`

<</details>

<details>
<summary>Какая информация хранится в /etc/passwd? объясните каждое поле</summary><br>

`/etc/passwd` - это конфигурационный файл, который содержит информацию о пользователях. Каждая запись в этом файле имеет 7 полей,

`имя пользователя:пароль:UID:GID:Комментарий:домашний каталог:оболочка`

`имя пользователя` - Имя пользователя.

`password` - Это поле фактически является заполнителем поля пароля. По соображениям безопасности, это поле не содержит пароля, а просто обозначение (x) для зашифрованного пароля, хранящегося в файле `/etc/shadow`.

`UID` - Идентификатор пользователя.

`GID` - Идентификатор группы 

`Comment` - Это поле предназначено для предоставления описания о пользователе.

`home directory` - Абсолютный путь к домашнему каталогу пользователя. Этот каталог создается после добавления пользователя.

`shell` - Это поле содержит абсолютный путь к оболочке, которая будет использоваться соответствующим пользователем.
<</details>

<details>
<summary>Как добавить нового пользователя в систему, не предоставляя ему возможности войти в систему?</summary><br><b>

`adduser имя_пользователя --shell=/bin/false --no-create-home`
Вы также можете добавить пользователя, а затем отредактировать /etc/passwd.
</b><</details>

<details>
<summary>Как переключиться на другого пользователя? Как переключиться на пользователя root? </summary><br><b>

команда su.
Используйте su - для перехода под root
</b><</details>

<details>
<summary>Что такое UID пользователя root? А как насчет обычного пользователя? </summary><br>

UID пользователя root равен 0

Значения по умолчанию UID_MIN и UID_MAX в `/etc/login.defs`
`UID_MIN` равен `1000`
`UID_MAX` - `60000`.

На самом деле, мы можем изменить это значение. Но UID < 1000 зарезервированы для системных учетных записей.
Поэтому, согласно конфигурации по умолчанию, для обычного пользователя UID начинается с `1000`. 
<</details>

<details>
<summary>Что делать, если вы потеряли/забыли пароль root?</summary><br><b>

Переустановка ОС НЕ является правильным ответом :)
</b><</details>

<details>
<summary>Что такое /etc/skel? </summary><br>

`/etc/skel` - это каталог, который содержит файлы или каталоги, поэтому при создании нового пользователя эти файлы/каталоги, созданные в `/etc/skel`, будут скопированы в домашний каталог пользователя.
<</details>

<details>
<summary>Как посмотреть список тех, кто вошел в систему?</summary><br><b>

Использование команды `last`.
</b><</details>

<details>
<summary>Объясните, что делает каждая из следующих команд:

  * useradd
  * usermod
  * whoami
  * id</summary><br><b>

  `useradd` - Команда для создания новых пользователей 
  `usermod` - Изменить настройки пользователей
  `whoami` - Выводит имя пользователя, под которым мы в данный момент вошли в систему.
  `id` - печатает  
</b><</details>

<details>
<summary>Вы запустили <code>grep $(whoami) /etc/passwd</code>, но результат пуст. Какова может быть причина этого? </summary><br><b>

Пользователь, которого вы используете, не определяется локально, а поступает из служб, таких как LDAP.<br>
Вы можете проверить с помощью: `getent passwd`.
</b><</details>

#### Linux Hardware

<details>
<summary>Где можно найти информацию о процессоре (например, количество CPU)?</summary><br><b>

/proc/cpuinfo

Вы также можете использовать `nproc` для количества процессоров
</b><</details

<details>
<summary>Как можно распечатать информацию о BIOS, материнской плате, процессоре и оперативной памяти?</summary><br><b>

dmidecoode
</b><</details

<details>
<summary>Как вы можете распечатать всю информацию о подключенных блочных устройствах в вашей системе?</summary><br><b>

lsblk
</b><</details

<details>
<summary>Правда или ложь? В пространстве пользователя приложения не имеют полного доступа к аппаратным ресурсам</summary><br><b>

Верно. Только в пространстве ядра они имеют полный доступ к аппаратным ресурсам.
</b><</details

#### Linux - Безопасность

<details>
<summary>Как создать закрытый ключ для ЦС (центра сертификации)?</summary><br><b>

Один из способов - использовать openssl таким образом:

`openssl genrsa -aes256 -out ca-private-key.pem 4096`
</b><</details

<details>
<summary>Как создать открытый ключ для ЦС (центра сертификации)?</summary><br><b>

`openssl req -new -x509 -days 730 -key [имя файла закрытого ключа] -sha256 -out ca.pem`.

Если использовать закрытый ключ из предыдущего вопроса, то команда будет следующей:

`openssl req -new -x509 -days 730 -key ca-private-key.pem -sha256 -out ca.pem`.
</b><</details

#### Linux - Пространства имен

<details>
<summary>Какие типы пространств имен существуют в Linux?</summary><br><b>

  - Пространства имен идентификаторов процессов: эти пространства имен включают независимый набор идентификаторов процессов
  - Пространства имен монтирования: Изоляция и контроль точек монтирования
  - Сетевые пространства имен: Изолирует системные сетевые ресурсы, такие как таблица маршрутизации, интерфейсы, ARP-таблица и т.д.
  - Пространства имен UTS: Изолируйте хост и домены
  - Пространства имен IPC: Изолирует межпроцессные коммуникации
  - Пространства имен пользователей: Изолируйте идентификаторы пользователей и групп
  - Пространства имен времени: Изолирует машину времени
</b><</details

<details>
<summary>Правда или ложь? В каждом пространстве имен PID (Process ID) первому процессу присваивается номер 1</summary><br><b>.

Верно. Внутри пространства имен это PID 1, в то время как в родительском пространстве имен PID другой.
</b><</details

<details>
<summary>Истина или ложь? В дочернем пространстве имен PID все процессы знают о родительском пространстве имен PID и процессах, а родительское пространство имен PID не имеет видимости процессов дочернего пространства имен PID</summary><br><b>.

Ложь. Верно обратное. Родительское пространство имен PID знает и имеет видимость процессов в дочернем пространстве имен PID, а дочернее пространство имен PID не имеет видимости того, что происходит в родительском пространстве имен PID.
</b><</details

<details>
<summary>Истина или ложь? По умолчанию, при создании двух отдельных сетевых пространств имен, пинг из одного пространства имен в другое будет работать нормально</summary><br><b>.

Ложь. Сетевое пространство имен имеет свои собственные интерфейсы и таблицу маршрутизации. Не существует способа (например, без создания моста) для одного сетевого пространства имен связаться с другим.
</b><</details

<details>
<summary>Правда или ложь? При использовании пространств имен UTS процессы могут выглядеть так, как будто они работают на разных хостах и доменах, хотя выполняются на одном хосте</summary><br><b>.

Правда
</b><</details

<details>
<summary>Истина или ложь? Невозможно иметь пользователя root с ID 0 в пространствах имен дочерних пользователей</summary><br><b>

Ложь. В каждом дочернем пространстве имен пользователя можно иметь отдельного корневого пользователя с uid, равным 0.
</b><</details

<details>
<summary>Для чего используются пространства имен времени?</summary><br><b>

В пространствах имен времени процессы могут использовать различное системное время.
</b><</details

#### Linux - Виртуализация

<details>
<summary>Какие решения виртуализации доступны для Linux?</summary><br><b>

  * [KVM](https://www.linux-kvm.org/page/Main_Page)
  * [XEN](http://www.xen.org/)
  * [VirtualBox](https://www.virtualbox.org/)
  * [Linux-VServer](http://linux-vserver.org/Welcome_to_Linux-VServer.org)
  * [User-mode Linux](http://user-mode-linux.sourceforge.net/)
  * ...
</b><</details

<details>
<summary>Что такое KVM?</summary><br><b>

Это технология виртуализации с открытым исходным кодом, используемая для работы на аппаратном обеспечении x86. 

Из официального [docs](https://www.linux-kvm.org/page/Main_Page)
Рекомендуем прочитать:
  * [Статья Red Hat - Что такое KVM?](https://www.redhat.com/en/topics/virtualization/what-is-KVM)
</b><</details

<details>
<summary>Что такое Libvirt? </summary><br><b>

Это набор программного обеспечения с открытым исходным кодом, используемый для управления виртуальными машинами. Его можно использовать с: KVM, Xen, LXC и другими. Его также называют Libvirt Virtualization API.

Из официального [docs](https://libvirt.org/)
Поддерживаемые гипервизоры [документация](https://libvirt.org/drivers.html)
</b><</details

#### Linux - AWK

<details>
<summary>Что делает команда <code>awk</code>? Использовали ли вы ее? Для чего? </summary><br><b>

Из Википедии: "AWK - это специфический язык, предназначенный для обработки текста и обычно используемый в качестве инструмента извлечения данных и составления отчетов".
</b><</details

<details>
<summary>Как вывести 4-ю колонку в файле?</summary><br><b>

`awk '{print $4}' file`
</b><</details

<details>
<summary>Как вывести каждую строку, длина которой превышает 79 символов?</summary><br><b>

`awk 'length($0) > 79' file`
</b><</details

<details>
<summary>Что делает команда <code>lsof</code>? Использовали ли вы ее? Для чего? </summary><br><b>
</b><</details

<details>
<summary>В чем разница между find и locate? </summary><br><b>
</b><</details

<details>
<summary>Как пользовательский процесс выполняет привилегированную операцию, например, чтение с диска?</summary><br><b>

Использование системных вызовов
</b><</details

#### Linux - Системные вызовы

<details>
<summary>Что такое системный вызов? С какими системными вызовами вы знакомы? </summary><br><b>
</b><</details

<details>
<summary>Как программа выполняет системный вызов?</summary><br><b>

- Программа выполняет инструкцию trap. Инструкция переходит в ядро, повышая привилегированный уровень до уровня ядра.
- Попав в пространство ядра, он может выполнить любую привилегированную операцию
- После завершения он вызывает инструкцию "return-from-trap", которая возвращается в пространство пользователя, снижая уровень привилегий до уровня пользовательского пространства.
</b><</details

<details>
<summary>Объяснение системного вызова fork()</summary><br><b>

fork() используется для создания нового процесса. Она делает это путем клонирования вызывающего процесса, но дочерний процесс имеет свой собственный PID, и любые блокировки памяти, операции ввода/вывода и семафоры не наследуются.
</b><</details

<details>
<summary>Каково возвращаемое значение fork()? </summary><br><b>

  - В случае успеха, PID дочернего процесса в родительском и 0 в дочернем процессе
  - При ошибке, -1 в родительском
</b><</details

<details>
<summary>Назовите одну причину отказа fork()</summary><br><b>

Недостаточно памяти для создания нового процесса
</b><</details

<details>
<summary>Зачем нам нужен системный вызов wait()?</summary><br><b>

wait() используется родительским процессом для ожидания завершения выполнения дочернего процесса.
Если wait не используется родительским процессом, то дочерний процесс может стать зомби-процессом.
</b><</details

<details>
<summary>Как ядро уведомляет родительский процесс о завершении дочернего процесса?</summary><br><b>

Ядро уведомляет родителя, посылая ему сигнал SIGCHLD.
</b><</details

<details>
<summary>Чем waitpid() отличается от wait()?</summary><br><b>

Функция waitpid() является неблокирующей версией функции wait().<br>
Он также поддерживает использование библиотечных процедур (например, system()) для ожидания дочернего процесса без беспорядка с другими дочерними процессами, для которых процесс не ждал.
</b><</details

<details>
<summary>Истина или ложь? Системный вызов wait() не вернется, пока дочерний процесс не будет запущен и завершен</summary><br><b>

Верно в большинстве случаев, хотя бывают случаи, когда wait() возвращается до выхода дочерней программы.
</b><</details

<details>
<summary>Объяснение системного вызова exec()</summary><br><b>

Он преобразует текущую запущенную программу в другую программу.<br>
Получив имя исполняемого файла и некоторые аргументы, она загружает код и статические данные из указанного исполняемого файла и перезаписывает свой текущий сегмент кода и текущие статические данные кода. После инициализации своего пространства памяти (например, стека и кучи) ОС запускает программу, передавая любые аргументы в качестве argv этого процесса.
</b><</details

<details>
<summary>Истина или ложь? Успешный вызов exec() никогда не возвращается</summary><br><b>

Правда<br>
Поскольку успешный exec заменяет текущий процесс, он не может ничего вернуть процессу, который сделал вызов.
</b><</details

<details>
<summary>Какой системный вызов используется для листинга файлов?</summary><br><b>
</b><</details

<details>
<summary>Какие системные вызовы используются для создания нового процесса?</summary><br><b>

fork(), exec() и системный вызов wait() также включены в этот рабочий процесс.
</b><</details

<details>
<summary>Что делает execve()?</summary><br><b>

Выполняет программу. Программа передается в виде имени файла (или пути) и должна быть двоичным исполняемым файлом или сценарием.
</b><</details

<details>
<summary>Каково возвращаемое значение malloc? </summary><br><b>
</b><</details

<details>
<summary>Объясните системный вызов pipe(). Для чего он используется? </summary><br><b>

[Реализация труб в Unix](https://toroid.org/unix-pipe-implementation)

"Трубы" обеспечивают однонаправленный канал межпроцессной связи. Труба имеет конец для чтения и конец для записи. Данные, записанные на конец трубы для записи, могут быть считаны с конца трубы для чтения.
Труба создается с помощью pipe(2), которая возвращает два файловых дескриптора, один из которых относится к концу трубы для чтения, а другой - для записи".
</b><</details

<details>
<summary>Что происходит, когда вы выполняете <code>ls -l</code>? </summary><br><b>

* Shell читает входные данные с помощью функции getline(), которая считывает поток входного файла и сохраняет в буфер в виде строки.
* Буфер разбивается на лексемы и хранится в массиве таким образом: {"ls", "-l", "NULL"}
* Shell проверяет, требуется ли расширение (в случае ls *.c).

* Как только программа в памяти, начинается ее выполнение. Сначала с вызова readdir()

Примечания:

* getline() происходит из библиотеки GNU C и используется для чтения строк из входного потока и сохранения этих строк в буфере.
</b><</details

<details>
<summary>Что происходит, когда вы выполняете <code>ls -l *.log</code>? </summary><br><b>
</b><</details

<details>
<summary>Что делает системный вызов readdir()?</summary><br><b>
</b><</details

<details>
<summary>Что именно делает команда <code>alias x=y</code>? </summary><br><b>
</b><</details

<details>
<summary>Почему запуск новой программы осуществляется с помощью системных вызовов fork() и exec()? Почему не был разработан другой API, где для запуска новой программы достаточно одного вызова? </summary><br><b>

Этот способ обеспечивает большую гибкость. Например, он позволяет оболочке выполнять код после вызова fork(), но до вызова exec(). Такой код может быть использован для изменения окружения программы, которую она собирается выполнить.
</b><</details

<details>
<summary>Кратко описывает, что происходит при выполнении команды в оболочке</summary><br><b>

Оболочка выясняет с помощью переменной PATH, где в файловой системе находится исполняемый файл команды. Затем он вызывает fork() для создания нового дочернего процесса для выполнения команды. После успешного выполнения fork вызывается вариант exec() для выполнения команды и, наконец, ожидание завершения команды с помощью wait(). Когда дочерний процесс завершает работу, оболочка возвращается из wait() и снова выводит приглашение.
</b><</details

#### Файловая система и файлы Linux

<details>
<summary>Как создать файл определенного размера?</summary><br><b>

Есть несколько способов сделать это:

  * dd if=/dev/urandom of=new_file.txt bs=2MB count=1
  * truncate -s 2M new_file.txt
  * fallocate -l 2097152 new_file.txt
</b><</details

<details>
<summary>Что делает следующий блок?

```
open("/my/file") = 5
read(5, "содержимое файла")
```
</summary><br><b>

Эти системные вызовы читают файл <code>/my/file</code>, а 5 - это номер дескриптора файла.
</b><</details

<details>
<summary>Описание трех различных способов удаления файла (или его содержимого)</summary><br><b>
</b><</details

<details>
<summary>В чем разница между процессом и потоком?</summary><br><b>
</b><</details

<details>
<summary>Что такое контекстный переключатель?</summary><br><b>

Из [wikipedia](https://en.wikipedia.org/wiki/Context_switch): переключение контекста - это процесс сохранения состояния процесса или потока, чтобы его можно было восстановить и возобновить выполнение в более поздний момент.
</b><</details

<details>
<summary>Вы обнаружили, что есть сервер с высокой загрузкой ЦП, но не нашли процесса с высокой загрузкой ЦП. Как такое возможно? </summary><br><b>
</b><</details

##### Linux Advanced - Networking

<details>
<summary>Когда вы запускаете <code>ip a</code>, вы видите, что есть устройство под названием 'lo'. Что это такое и зачем оно нам нужно? </summary><br><b>
</b><</details

<details>
<summary>Что делает команда <code>traceroute</code>? Как она работает? </summary><br><b>

Другой распространенный способ задать этот вопрос - "какую часть заголовка tcp изменяет traceroute?".
</b><</details

<details>
<summary>Что такое сетевое связывание? С какими типами вы знакомы? </summary><br><b>
</b><</details

<details>
<summary>Как связать два отдельных сетевых пространства имен, чтобы можно было пинговать интерфейс одного пространства имен из второго? </summary><br><b>
</b><</details

<details>
<summary>Что такое cgroups?</summary><br><b>
</b><</details

<details>
<summary>Объяснение дескриптора процесса и структуры задачи</summary><br><b>
</b><</details

<details>
<summary>Каковы различия между потоками и процессами?</summary><br><b>
</b><</details

<details>
<summary>Объяснение потоков ядра</summary><br><b>
</b><</details

<details>
<summary>Что происходит, когда используется системный вызов socket?</summary><br><b>

Это хорошая статья по теме: https://ops.tips/blog/how-linux-creates-sockets
</b><</details

<details>
<summary>Вы выполнили скрипт и во время его выполнения случайно удалили его. Можно ли восстановить скрипт, пока он все еще выполняется? </summary><br><b>
</b><</details

#### Память Linux

<details>
<summary>В чем разница между MemFree и MemAvailable в /proc/meminfo?</summary><br><b>

MemFree - Объем неиспользуемой физической оперативной памяти в вашей системе
MemAvailable - Объем доступной памяти для новых рабочих нагрузок (без принуждения системы к использованию свопа), основанный на MemFree, Active(file), Inactive(file) и SReclaimable.
</b><</details

<details>
<summary>В чем разница между пейджингом и свопингом?</summary><br><b>
</b><</details

<details>
<summary>Объясните, что такое OOM killer</summary><br><b>
</b><</details

#### Распределение

<details>
<summary>Что такое дистрибутив Linux?</summary><br><b>
</b><</details

<details>
<summary>Какие дистрибутивы Linux вы знаете? </summary><br><b>
</b><</details

<details>
<summary>Какие компоненты входят в дистрибутив Linux?</summary><br><b>

* Ядро
* Коммунальные услуги
* Услуги
* Управление программным обеспечением/пакетами
</b><</details

#### Linux - Sed

<details>
<summary>Используя sed, извлеките дату из следующей строки: <code>201.7.19.90 - - [05/Jun/1985:13:42:99 +0000] "GET /site HTTP/1.1" 200 32421</code></summary><br><b>

`echo $line | sed 's/.*\[//g;s/].*//g;s/:.*//g'`
</b><</details


#### Linux - Misc

<details>
<summary>Как сгенерировать случайную строку?</summary><br><b>

Один из способов - выполнить следующее: `cat /proc/sys/kernel/random/uuid`.
</b><</details

<details>
<summary>Что такое дистрибутив Linux?</summary><br><b>

* Коллекция пакетов - ядро, GNU, сторонние приложения, ...
* Иногда дистрибутивы хранят некоторую информацию о дистрибутиве в файле `/etc/*-release`.
    * Например, для дистрибутива Red Hat это будет `/etc/redhat-release`, а для Amazon - `/etc/os-release`.
    * `lsb_release` - это общая команда, которую можно использовать в различных дистрибутивах.
</b><</details

<details>
<summary>Имя 5 команд, состоящих из двух букв</summary><br><b>

ls, wc, dd, df, du, ps, ip, cp, cd ...
</b><</details

<details>
<summary>Какие существуют способы создания нового пустого файла?</summary><br><b>

  * touch new_file
  * echo "" > new_file
</b><</details

<details>
<summary>Как работает `cd -`? Как он узнает предыдущее местоположение? </summary><br><b>

</b><</details

<details>
<summary>Перечень трех способов печати всех файлов в текущем каталоге</summary><br><b>

* ls
* найти .
* echo *
</b><</details

<details>
<summary>Как подсчитать количество строк в файле? А как насчет слов? </summary><br><b>
</b><</details

<details>
<summary>Вы определяете x=2 в /etc/bashrc и x=6 ~/.bashrc, затем входите в систему. Каким будет значение x? </summary><br><b>
</b><</details

<details>
<summary>В чем разница между человеком и информацией?</summary><br><b>

Хороший ответ можно найти [здесь](https://askubuntu.com/questions/9325/what-is-the-difference-between-man-and-info-documentation)
</b><</details

<details>
<summary>Объясните понятие "переменные среды". Как перечислить все переменные среды? </summary><br><b>
</b><</details

<details>
<summary>Что такое TTY-устройство?</summary><br><b>
</b><</details

<details>
<summary>Как создать собственные переменные окружения?</summary><br><b>

Например, `X=2`. Но это сохранится в новых оболочках. Чтобы иметь его и в новых оболочках, используйте `export X=2`.
</b><</details

<details>
<summary>Что означает двойное тире (--)? </summary><br><b>

Он используется в командах, чтобы отметить конец опций команды. Один из распространенных примеров - использование в git для отбрасывания локальных изменений: `git checkout -- some_file`.
</b><</details

<details>
<summary>Карты дикости реализуются в пространстве пользователя или ядра? </summary><br><b>
</b><</details

<details>
<summary>Если я подключаю новое устройство к машине Linux, где в системе будет создана новая запись/файл устройства?</summary><br><b>

/dev
</b><</details

<details>
<summary>Почему в человеке существуют различные разделы? В чем разница между секциями? </summary><br><b>
</b><</details

<details>
<summary>Что такое пользовательский режим Linux?</summary><br><b>
</b><</details

<details>
<summary>По какой лицензии распространяется Linux? </summary><br><b>

GPL v2
</b><</details

## Операционная система

### Упражнения по операционной системе

|Name|Topic|Objective & Instructions|Solution|Comments|
|--------|--------|------|----|----|
|Fork 101|Fork|[Link](exercises/os/fork_101.md)|[Link](exercises/os/solutions/fork_101_solution.md)
|Fork 102|Fork|[Link](exercises/os/fork_102.md)|[Link](exercises/os/solutions/fork_102_solution.md)

### Операционная система - самооценка

<details>
<summary>Что такое операционная система?</summary><br><b>

Из книги "Операционные системы: Три простых элемента":

"отвечает за простоту запуска программ (даже позволяет, казалось бы, запускать много программ одновременно), позволяет программам совместно использовать память, позволяет программам взаимодействовать с устройствами и другие забавные вещи".
</b><</details

#### Операционная система - процесс

<details>
<summary>Вы можете объяснить, что такое процесс? </summary><br><b>

Процесс - это запущенная программа. Программа - это одна или несколько инструкций, и программа (или процесс) выполняется операционной системой.
</b><</details

<details>
<summary>Если бы вам пришлось разрабатывать API для процессов в операционной системе, как бы выглядел этот API?</summary><br><b>

Он будет поддерживать следующее:

* Создать - позволяет создавать новые процессы
* Удалить - позволяет удалять/уничтожать процессы
* Состояние - позволяет проверить состояние процесса, запущен ли он, остановлен, ждет и т.д.
* Остановить - позволяет остановить запущенный процесс
</b><</details

<details>
<summary>Как создается процесс?</summary><br><b>

* ОС считывает код программы и все дополнительные данные, относящиеся к ней.
* Код программы загружается в память или, более конкретно, в адресное пространство процесса.
* Память выделяется для стека программы (он же стек времени выполнения). Стек также инициализируется ОС данными типа argv, argc и параметрами для main().
* Память выделяется для кучи программы, которая необходима для динамически распределяемых данных, таких как структуры данных, связанные списки и хэш-таблицы.
* Выполняются задачи инициализации ввода/вывода, как в системах на базе Unix/Linux, где каждый процесс имеет 3 файловых дескриптора (вход, выход и ошибка)
* ОС выполняет программу, начиная с main()
</b><</details

<details>
<summary>Правда или ложь? Загрузка программы в память происходит с нетерпением (все сразу)</summary><br><b>

Ложь. В прошлом это было верно, но современные операционные системы выполняют ленивую загрузку, что означает, что сначала загружаются только те части, которые необходимы для выполнения процесса.
</b><</details

<details>
<summary>Что такое различные состояния процесса?</summary><br><b>

* Работает - выполняет инструкции.
* Готов - готов к запуску, но по разным причинам приостановлен.
* Заблокирован - ожидает завершения некоторой операции. Например, запрос диска на ввод/вывод
</b><</details

<details>
<summary>Каковы некоторые причины блокировки процесса?</summary><br><b>

  - Операции ввода-вывода (например, чтение с диска)
  - Ожидание пакета из сети
</b><</details

<details>
<summary>Что такое межпроцессное взаимодействие (IPC)? </summary><br><b>
</b><</details

<details>
<summary>Что такое "разделение времени"? </summary><br><b>

Даже при использовании системы с одним физическим процессором можно позволить нескольким пользователям работать на нем и запускать программы. Это возможно с помощью разделения времени, когда вычислительные ресурсы разделяются таким образом, что пользователю кажется, что система имеет несколько процессоров, но на самом деле это просто один процессор, разделяемый путем применения мультипрограммирования и многозадачности.
</b><</details

<details>
<summary>Что такое "совместное использование пространства"?</summary><br><b>

В некотором роде противоположность совместного использования времени. Если при совместном использовании времени ресурс используется в течение некоторого времени одним субъектом, а затем этот же ресурс может быть использован другим, то при совместном использовании пространства пространство используется несколькими субъектами, но таким образом, что оно не передается между ними.<br>
Он используется одним субъектом до тех пор, пока этот субъект не решит от него избавиться. Возьмем, к примеру, хранилище. В хранилище файл принадлежит вам до тех пор, пока вы не решите его удалить.
</b><</details

<details>
<summary>Какой компонент определяет, какой процесс запущен в данный момент времени?</summary><br><b>

Планировщик процессора
</b><</details

#### Операционная система - Память

<details>
<summary>Что такое "виртуальная память" и для каких целей она служит?</summary><br><b>
</b><</details

<details>
<summary>Что такое пейджинг по требованию?</summary><br><b>
</b><</details

<details>
<summary>Что такое copy-on-write или shadowing? </summary><br><b>
</b><</details

<details>
<summary>Что такое ядро, и что оно делает?</summary><br><b>

Ядро является частью операционной системы и отвечает за такие задачи, как:

  * Выделение памяти
  * Планирование процессов
  * Процессор управления
</b><</details

<details>
<summary>Правда или ложь? Некоторые части кода в ядре загружаются в защищенные области памяти, чтобы приложения не могли их перезаписать</summary><br><b>.

Правда
</b><</details

<details>
<summary>Что такое POSIX? </summary><br><b>
</b><</details

<details>
<summary>Объясните, что такое семафор и какова его роль в операционных системах</summary><br><b>
</b><</details

<details>
<summary>Что такое кэш? Что такое буфер? </summary><br><b>

Буфер: Зарезервированное место в оперативной памяти, которое используется для временного хранения данных
Кэш: Кэш обычно используется в процессах чтения и записи на диск, чтобы ускорить процесс, делая схожие данные, используемые различными программами, легко доступными.
</b><</details

## Виртуализация

<details>
<summary>Что такое виртуализация? </summary><br><b>

Виртуализация использует программное обеспечение для создания уровня абстракции над компьютерным оборудованием, который позволяет разделить аппаратные элементы одного компьютера - процессоры, память, хранилище и другие - на несколько виртуальных компьютеров, обычно называемых виртуальными машинами (ВМ).
</b><</details

<details>
<summary>Что такое гипервизор?</summary><br><b>

Red Hat: "Гипервизор - это программное обеспечение, которое создает и запускает виртуальные машины (ВМ). Гипервизор, иногда называемый монитором виртуальных машин (VMM), изолирует операционную систему и ресурсы гипервизора от виртуальных машин и обеспечивает создание и управление этими ВМ".

Подробнее [здесь] (https://www.redhat.com/en/topics/virtualization/what-is-a-hypervisor)
</b><</details

<details>
<summary>Какие типы гипервизоров существуют?</summary><br><b>

Hosted hypervisors и bare-metal hypervisors.
</b><</details

<details>
<summary>Каковы преимущества и недостатки пустого гипервизора по сравнению с размещенным гипервизором?</summary><br><b>

Благодаря наличию собственных драйверов и прямому доступу к аппаратным компонентам, "пустой" гипервизор часто имеет лучшую производительность, а также стабильность и масштабируемость.

С другой стороны, вероятно, будут некоторые ограничения в отношении загрузки (любых) драйверов, поэтому размещенный гипервизор обычно выигрывает за счет лучшей совместимости с оборудованием.
</b><</details

<details>
<summary>Какие существуют типы виртуализации?</summary><br><b>

Виртуализация операционной системы
Виртуализация сетевых функций
Виртуализация рабочего стола
</b><</details

<details>
<summary>Является ли контейнеризация разновидностью виртуализации?</summary><br><b>

Да, это виртуализация на уровне операционной системы, где ядро является общим и позволяет использовать несколько изолированных экземпляров пользовательского пространства.
</b><</details

<details>
<summary>Как внедрение виртуальных машин изменило индустрию и способ развертывания приложений?</summary><br><b>

Внедрение виртуальных машин позволило компаниям развернуть несколько бизнес-приложений на одном и том же оборудовании, при этом каждое приложение отделено от другого защищенным способом, где каждое работает на своей отдельной операционной системе.
</b><</details

## Python

### Упражнения по Python

|Name|Topic|Objective & Instructions|Solution|Comments|
|--------|--------|------|----|----|
| Определить тип данных | Типы данных | [Упражнение](exercises/python/data_types.md) | [Решение](exercises/python/solutions/data_types_solution.md)
| Определить тип данных - Advanced | Data Types | [Exercise](exercises/python/advanced_data_types.md) | [Solution](exercises/python/solutions/advanced_data_types_solution.md)
| Обратная строка | Строки | [Упражнение](exercises/python/reverse_string.md) | [Решение](exercises/python/solutions/reverse_string.md)
| Compress String | Strings | [Exercise](exercises/python/compress_string.md) | [Solution](exercises/python/solutions/compress_string.md)

### Самооценка Python

<details>
<summary>Каковы некоторые особенности языка программирования Python?</summary><br><b>

```
1. Это высокоуровневый язык программирования общего назначения, созданный в 1991 году Гвидо Ван Розумом.
2. Язык интерпретируемый, наиболее используемой/поддерживаемой реализацией является CPython (написанный на C).
3. Он сильно типизирован. Дисциплина типизации - утиная типизация и постепенная.
4. Python ориентирован на удобочитаемость и использует пробелы/идентификацию вместо скобок { }
5. Менеджер пакетов python называется PIP "pip устанавливает пакеты" и имеет более 200.000 доступных пакетов.
6. Python поставляется с установленным pip и большой стандартной библиотекой, которая предлагает программисту множество готовых решений.
7. В python **Все** является объектом.
```
</b><</details

<details>
<summary>Какие встроенные типы есть в Python?</summary><br><b>

    Список
    Словарь
    Установите
    Числа (int, float, ...)
    Строка
    Bool
    Кортеж
    Frozenset
</b><</details

<details>
<summary>Что такое изменяемость? Какие из встроенных типов в Python являются изменяемыми? </summary><br><b>

Мутабельность определяет, можете ли вы изменять объект определенного типа.

К изменяемым типам данных относятся:

    Список
    Словарь
    Установите

Неизменяемыми типами данных являются:

    Числа (int, float, ...)
    Строка
    Bool
    Кортеж
    Frozenset
</b><</details

#### Python - Булевы

<details>
<summary>Каков результат каждого из следующих действий?

  - 1 > 2
  - 'b' > 'a'
  * 1 == 'один'
  - 2 > 'one'</summary><br><b>

  * Ложь
  * Правда
  * Ложь
  * TypeError
</b><</details

<details>
<summary>Что является результатом `bool("")`? А что насчет `bool("")`? Объясните</summary><br><b>

bool("") -> оценивается в False<br>
bool(" ") -> оценивается как True
</b><</details

<details>
<summary>Каков результат выполнения <code>[] is not []</code>? объясните результат</summary><br><b>

Он оценивается как True.<br>
Причина в том, что два созданных пустых списка являются разными объектами. Функция `x is y` имеет значение true только в том случае, если x и y - один и тот же объект.
</b><</details

<details>
<summary>Каков результат выполнения <code>True-True</code>? </summary><br><b>

0
</b><</details

#### Python - Строки

<details>
<summary>Истина или ложь? Строка является неизменяемым типом данных в Python</summary><br><b>

Правда
</b><</details

<details>
<summary>Как проверить, начинается ли строка с буквы?</summary><br><b>

Regex:

```
импортировать ре
if re.match("^[a-zA-Z]+.*", string):
```

встроенная строка:

```
если string и string[0].isalpha():
```
</b><</details

<details>
<summary>Как проверить, все ли символы в заданной строке являются цифрами?</summary><br><b>

`string.isdigit`
</b><</details

<details>
<summary>Как удалить косую черту ('/') из строки?</summary><br><b>

`string.rstrip('/')`
</b><</details

<details>
<summary>Что является результатом каждого из следующих действий?

  - "abc "*3
  - "abc "*2.5
  - "abc "*2.0
  - "abc "* Истина
  - "abc "*False</summary><br><b>

* abcabcabc
* TypeError
* TypeError
* "abc"
* ""
</b><</details

<details>
<summary>Улучшите следующий код:

```
char = input("Вставьте символ: ")
если char == "a" или char == "o" или char == "e" или char == "u" или char == "i":
    print("Это гласная!").
```
</summary><br><b>

```
char = input("Вставьте символ: ") # Для читабельности
if lower(char[0]) in "aieou": # Заботится о множественных символах и отдельных случаях
    print("Это гласная!").
```
ИЛИ
```
if lower(input("Вставьте символ: ")[0]) in "aieou": # Заботится о множественных символах и малом/заглавном регистре
    print("Это гласная!").
```
</b><</details

#### Python - Функции

<details>
<summary>Как определить функцию в Python?</summary><br><b>
Использование ключевого слова `def`. Примеры:

```
def sum(a, b):
    возврат (a + b)
```
</b><</details

<details>
<summary>В Python функции являются объектами первого класса. Что это значит? </summary><br><b>

В общем, объекты первого класса в языках программирования - это объекты, которые могут быть присвоены переменной, использованы в качестве возвращаемого значения и могут быть использованы в качестве аргументов или параметров.<br>
В python вы можете обращаться с функциями таким образом. Допустим, у нас есть следующая функция

```
def my_function():
    возврат 5
```

Вы можете присвоить функцию переменной, например, так `x = my_function`, или вернуть функции в качестве возвращаемых значений, например, так `return my_function`.
</b><</details

#### Python - Integer

<details>
<summary>Напишите функцию для определения того, является ли число палиндромом</summary><br><b>

- Код:

```
from typing import Union

def isNumberPalindrome(number: Union[int, str]) -> bool:
    if isinstance(number, int):
        число = str(число)
    return number == number[::-1]

print(isNumberPalindrome("12321"))
```

- Используя Python3.10, который допускает использование побитового оператора '|'. 

```
def isNumberPalindrome(number: int | str) -> bool:
    if isinstance(number, int):
        число = str(число)
    return number == number[::-1]

print(isNumberPalindrome("12321"))
```

Примечание: Использование нарезки для разворота списка может быть медленнее, чем другие варианты, такие как `reversed`, которые возвращают итератор.

- Результат:

```
Правда
```

</b><</details

#### Python - Циклы

<details>
<summary>Каков результат следующего блока кода?

```
x = ['a', 'b', 'c'].
для i в x:
    если i == 'b':
        x = ['z', 'y'].
    print(i)
```
</summary><br><b>

```
a
b
c
```
</b><</details

#### Python - ООП

<details>
<summary>Объяснение наследования и его использования в Python</summary><br><b>

```
По определению, наследование - это механизм, при котором объект действует как основа другого объекта, сохраняя все его свойства.
свойства.

Таким образом, если класс B наследует от класса A, все характеристики класса A будут доступны и в классе B.
Класс A будет "базовым классом", а класс B - "производным классом".

Это удобно, когда у вас есть несколько классов с одинаковыми функциональными возможностями.

Основной синтаксис следующий:

class Base: pass

class Derived(Base): pass

Более кованый пример:

класс Животное:
    def __init__(self):
        print("и я жив!").

    def eat(self, food):
        print("ñom ñom ñom", food)

класс Человек(Животное):
    def __init__(self, name):
        print('Меня зовут ', name)
        super().__init__()

    def write_poem(self):
        print('Foo bar bar foo foo bar!')

class Dog(Animal):
    def __init__(self, name):
        print('Меня зовут', name)
        super().__init__()

    def bark(self):
        print('гав-гав')


michael = Human('Michael')
michael.eat('Spam')
michael.write_poem()

bruno = Dog('Bruno')
bruno.eat('bone')
bruno.bark()

 Меня зовут Майкл.
 и я жив!
 ñom ñom ñom ñom Спам
 Foo bar bar foo foo foo bar!
 Меня зовут Бруно
 и я жив!
 ñom ñom ñom ñom bone
 гав-гав-гав

Вызов super() вызывает метод Base, таким образом, вызвав super().__init__(), мы вызвали метод Animal __init__.

Существует более продвинутая функция python под названием MetaClasses, которая помогает программисту напрямую управлять созданием классов.
```
</b><</details

<details>
<summary>Объяснение и демонстрация атрибутов класса и атрибутов экземпляра</summary><br><b>

В следующем блоке кода `x` является атрибутом класса, а `self.y` - атрибутом экземпляра

```
class MyClass(object):
    x = 1

    def __init__(self, y):
        self.y = y
```
</b><</details

#### Python - Исключения

<details>
<summary>Что такое ошибка? Что такое исключение? С какими типами исключений вы знакомы? </summary><br><b>

```
# Обратите внимание, что вам обычно не нужно знать процесс компиляции, но знание того, откуда все берется
# и давать полные ответы показывает, что вы действительно знаете, о чем говорите.

Как правило, каждый процесс компиляции состоит из двух этапов.
    - Анализ
    - Генерация кода.

    Анализ можно разделить на:
        1. Лексический анализ (Токенизация исходного кода)
        2. Синтаксический анализ (проверка легальности лексем, tldr, правильности синтаксиса)

               for i in 'foo'
                          ^
             SyntaxError: неверный синтаксис

        Мы пропустили ':'


        3. Семантический анализ (Контекстуальный анализ, легальный синтаксис все равно может вызвать ошибки, пытались ли вы делить на 0,
          хэшировать изменяемый объект или использовать необъявленную функцию?)

                 1/0
                ZeroDivisionError: деление на ноль

    Эти три этапа анализа отвечают за обработку ошибок.

    Второй этап будет отвечать за ошибки, в основном за синтаксические ошибки, наиболее распространенную ошибку.
    Третий этап будет отвечать за Исключения.

    Как мы видели, исключения - это семантические ошибки, существует множество встроенных исключений:

        ImportError
        ValueError
        KeyError
        FileNotFoundError
        IndentationError
        IndexError
        ...

    Вы также можете иметь определенные пользователем Исключения, которые должны наследоваться от класса `Exception`, прямо или косвенно.

    Основной пример:

    class DividedBy2Error(Exception):
        def __init__(self, message):
            self.message = сообщение


    def division(dividend,divisor):
        если делитель == 2:
            raise DividedBy2Error('Я не хочу, чтобы вы делили на 2!')
        возврат дивиденда / делителя

    division(100, 2)

     __main__.DividedBy2Error: Я не хочу, чтобы вы делили на 2!
```
</b><</details

<details>
<summary>Объяснение обработки исключений и их использования в Python</summary><br><b>

Исключения: Ошибки, обнаруженные во время выполнения, называются исключениями.

Обработка исключений:** Когда возникает ошибка, или, как мы ее называем, исключение, Python обычно останавливается и выдает сообщение об ошибке.</br>.
Исключения можно обрабатывать с помощью операторов `try` и `except` в python.

Пример: Следующий пример спрашивает пользователя о вводе до тех пор, пока не будет введено действительное целое число.</br>
Если пользователь введет нецелое значение, то возникнет исключение, и с помощью except оно перехватит это исключение и попросит пользователя снова ввести правильное целое число.


py
while True:
    попытаться:
        a = int(input("пожалуйста, введите целочисленное значение: "))
        перерыв
    except ValueError:
        print("Операции! Пожалуйста, введите правильное целочисленное значение.")

Для получения более подробной информации об ошибках и исключениях перейдите по этой ссылке [https://docs.python.org/3/tutorial/errors.html](https://docs.python.org/3/tutorial/errors.html)

</b><</details

<details>
<summary>Каков результат выполнения следующей функции?

```
def true_or_false():
    попытаться:
        вернуть True
    наконец:
        вернуть False
```
</summary><br><b>
Ложь
</b><</details

#### Встроенные функции Python

<details>
<summary>Объяснение следующих встроенных функций (их назначение + пример использования):

  * repr
  * любой
  * все</summary><br><b>
</b><</details

<details>
<summary>В чем разница между функцией repr и str?</summary><br><b>
</b><</details

<details>
<summary>Что такое метод __call__? </summary><br><b>

Он используется для эмуляции вызываемых объектов. Он позволяет вызывать экземпляр класса как функцию.

- Пример кода:

```
класс Foo:
    def __init__(self: object) -> None:
        пройти
    def __call__(self: object) -> None:
        print("Вызвано!")

f = Foo()
f()
```

- Результат:

```
Призван!
```

</b><</details

<details>
<summary>У классов тоже есть метод __call__? Для чего? </summary><br><b>
</b><</details

<details>
<summary>Для чего используется _ в Python?</summary><br><b>

1. Поиск перевода в i18n
2. Удержание результата последнего выполненного выражения или оператора в интерактивном интерпретаторе.
3. Как имя переменной общего назначения "на выброс". Например: x, y, _ = get_data() (x и y используются, но поскольку нам не важна третья переменная, мы ее "выбросили").
</b><</details

<details>
<summary>Объясните, что такое GIL</summary><br><b>
	Python Global Interpreter Lock (GIL) - это тип блокировки процесса, который используется в python всякий раз, когда он имеет дело с процессами. Как правило, Python использует только один поток для выполнения набора записанных утверждений. Это означает, что в python одновременно будет выполняться только один поток.
</b><</details

<details>
<summary>Что такое лямбда? Как она используется? </summary><br><b>

Выражение <code>lambda</code> - это "анонимная" функция, отличие от обычной определенной функции, использующей ключевое слово `def``, заключается в синтаксисе и использовании.

Синтаксис следующий:

lambda[parameters]: [выражение]``

**Примеры:**

* Лямбда-функция add 10 с любым переданным аргументом.

py
x = лямбда a: a + 10
print(x(10))


* Функция сложения

``py
сложение = лямбда x, y: x + y
print(addition(10, 20))
```

* Функция возведения в квадрат

``py
квадрат = лямбда x : x ** 2
print(square(5))
```
Вообще, согласно PEP 8, присвоение лямбда-выражения считается плохой практикой, они предназначены для использования в качестве параметров и внутри других определенных функций.

</b><</details

#### Свойства

<details>
<summary>Существуют ли в Python приватные переменные? Как сделать атрибут класса приватным? </summary><br><b>
</b><</details

<details>
<summary>Объясните следующее:

* getter
* setter
* deleter</summary><br><b>
</b><</details

<details>
<summary>Объясните, что такое @property</summary><br><b>
</b><</details

<details>
<summary>Как поменять значения между двумя переменными? </summary><br><b>

```
x, y = y, x
```
</b><</details

<details>
<summary>Объяснение магических переменных следующего объекта:

  * __dict__
</summary><br><b>
</b><</details

<details>
<summary>Напишите функцию, возвращающую сумму одного или нескольких чисел. Пользователь сам решит, сколько чисел использовать</summary><br><b>

Сначала вы спрашиваете пользователя о количестве чисел, которые будут использоваться. Используйте цикл while, который выполняется до тех пор, пока количество_чисел не станет равным 0, вычитая количество_чисел на единицу в каждом цикле. В цикле while вы хотите попросить пользователя ввести число, которое будет добавляться в переменную при каждом запуске цикла.

```
def return_sum():
	количество_чисел = int(input("Сколько чисел? "))
	общая_сумма = 0
	while amount_of_numbers != 0:
		num = int(input("Введите число. "))
		общая_сумма += num
		количество_чисел -= 1
	return total_sum

```
</b><</details

<details>
<summary>Выведите среднее значение из [2, 5, 6]. Оно должно быть округлено до 3 знаков после запятой</summary><br><b>

```
li = [2, 5, 6]
print("{0:.3f}".format(sum(li)/len(li))))
```
</b><</details

#### Python - Списки

<details>
<summary>Что такое кортеж в Python? Для чего он используется? </summary><br><b>

Кортеж - это встроенный тип данных в Python. Он используется для хранения нескольких элементов в одной переменной.
</b><</details

<details>
<summary>Список, как и кортеж, также используется для хранения нескольких элементов. В чем же разница между кортежем и списком? </summary><br><b>

Список, в отличие от кортежа, является изменяемым типом данных. Это означает, что мы можем изменять его и элементы в нем.
</b><</details

<details>
<summary>Как добавить число 2 в список <code>x = [1, 2, 3]</code></summary><br><b>

`x.append(2)`
</b><</details

<details>
<summary>Как проверить, сколько элементов содержит список?</summary><br><b>

`len(sone_list)`
</b><</details

<details>
<summary>Как получить последний элемент списка?</summary><br><b>

`some_list[-1]`
</b><</details

<details>
<summary>Как добавить элементы из [1, 2, 3] в список [4, 5, 6]?</summary><br><b>
x = [4, 5, 6]
x.extend([1, 2, 3])

Не используйте `append`, если вы не хотите, чтобы список состоял из одного элемента.
</b><</details

<details>
<summary>Как удалить первые 3 элемента из списка?</summary><br><b>

`my_list[0:3] = []`
</b><</details

<details>
<summary>Как получить максимальное и минимальное значения из списка?</summary><br><b>

```
Максимум: max(some_list)
Минимум: min(some_list)
```
</b><</details

<details>
<summary>Как получить 3 самых верхних/больших элемента из списка?</summary><br><b>

```
sorted(some_list, reverse=True)[:3]
```

Или

```
some_list.sort(reverse=True)
some_list[:3]
```
</b><</details

<details>
<summary>Как вставить элемент в начало списка? Как насчет двух элементов? </summary><br><b>

- Один пункт:

```
числа = [1, 2, 3, 4, 5]
numbers.insert(0, 0)
print(numbers)
```

- Несколько элементов или список:

```
numbers_1 = [2, 3, 4, 5]
числа_2 = [0, 1]
числа_1 = числа_2 + числа_1
print(numbers_1)
```

</b><</details

<details>
<summary>Как отсортировать список по длине элементов?</summary><br><b>

```
sorted_li = sorted(li, key=len)
```

Или без создания нового списка:

```
li.sort(key=len)
```
</b><</details

<details>
<summary>Вы знаете, в чем разница между list.sort() и sorted(list)? </summary><br><b>

* sorted(list) вернет новый список (исходный список не изменится)
* list.sort() вернет None, но список будет изменен на месте

* sorted() работает с любыми итерациями (словари, строки, ...)
* list.sort() быстрее, чем sorted(list) в случае списков
</b><</details

<details>
<summary>Преобразование каждой строки в целое число: <code>[['1', '2', '3'], ['4', '5', '6']]</code></summary><br><b>

```
nested_li = [['1', '2', '3'], ['4', '5', '6']].
[[int(x) for x in li] for li in nested_li]
```
</b><</details

<details>
<summary>Как объединить два отсортированных списка в один отсортированный список?</summary><br><b>

```
отсортированный(li1 + li2)
```

Другой способ:

```
i, j = 0
merged_li = []

while i < len(li1) and j < len(li2):
    if li1[i] < li2[j]:
        merged_li.append(li1[i])
        i += 1
    еще:
        merged_li.append(li2[j])
        j += 1

merged_li = merged_li + merged_li[i:] + merged_li[j:]
```
</b><</details

<details>
<summary>Как проверить, все ли элементы в заданном списке уникальны? Так, [1, 2, 3] уникален, но [1, 1, 2, 3] не уникален, потому что 1 существует дважды</summary><br><b>
</b>

Существует множество способов решения этой проблемы:<br>
<code># Примечание: :list и -> bool - это просто типизации python, они не нужны для правильного выполнения алгоритма. </code>.

Использование преимуществ сетов и лен:

```
def is_unique(l:list) -> bool:
    return len(set(l)) == len(l))
```

Его можно встретить и в других языках программирования.

```
def is_unique2(l:list) -> bool:
    видели = []

    для i в l:
        если я видел:
            вернуть False
        seen.append(i)
    вернуть True
```

Здесь мы просто считаем и убеждаемся, что каждый элемент повторяется только один раз.

```
def is_unique3(l:list) -> bool:
    для i в l:
        если l.count(i) > 1:
            вернуть False
    вернуть True
```

Этот, возможно, выглядит более замысловатым, но эй, односложные фразы.

```
def is_unique4(l:list) -> bool:
    return all(map(lambda x: l.count(x) < 2, l))
```
<</details

<details>
<summary>Вы имеете следующую функцию

```
def my_func(li = []):
    li.append("hmm")
    print(li)
```

Если мы вызовем его 3 раза, каков будет результат каждого вызова?
</summary><br><b>

```
['hmm'].
['hmm', 'hmm'].
['hmm', 'hmm', 'hmm'].
```
</b><</details


<details>
<summary>Как выполнить итерацию по списку?</summary><br><b>

```
для элемента в some_list:
    print(item)
```
</b><</details

<details>
<summary>Как выполнить итерацию по списку с индексами?</summary><br><b>

```
for i, item in enumerate(some_list):
    print(i)
```
</b><</details

<details>
<summary>Как начать итерацию списка со второго индекса?</summary><br><b>

Использование диапазона следующим образом

```
for i in range(1, len(some_list)):
    some_list[i]
```

Другой способ - использование нарезки

```
for i in some_list[1:]:
```
</b><</details

<details>
<summary>Как выполнить итерацию по списку в обратном порядке?</summary><br><b>

Метод 1
```
for i in reversed(li):
    ...
```

Метод 2
```
n = len(li) - 1
пока n > 0:
    ...
    n -= 1
```
</b><</details

<details>
<summary>Сортирует список списков по второму элементу каждого вложенного списка</summary><br><b>

```
li = [[1, 4], [2, 1], [3, 9], [4, 2], [4, 5]].

sorted(li, key=lambda l: l[1])
```

или

```
li.sort(key=lambda l: l[1)
```
</b><</details

<details>
<summary>Комбинируем [1, 2, 3] и ['x', 'y', 'z'] так, чтобы результат был [(1, 'x'), (2, 'y'), (3, 'z')]</summary><br><b>

```
nums = [1, 2, 3]
буквы = ['x', 'y', 'z'].

list(zip(nums, letters))
```
</b><</details

<details>
<summary>Что такое List Comprehension? Лучше ли оно, чем обычный цикл? Почему? Можете ли вы продемонстрировать, как его использовать? </summary><br><b>

Из [Docs](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions): "Постижения списков обеспечивают лаконичный способ создания списков. Обычно они применяются для создания новых списков, каждый элемент которых является результатом некоторых операций, применяемых к каждому члену другой последовательности или итерабельной последовательности, или для создания подпоследовательности тех элементов, которые удовлетворяют определенному условию.".

Это лучше, потому что они компактнее, быстрее и лучше читаются.

- Для петли:

```
number_lists = [[1, 7, 3, 1], [13, 93, 23, 12], [123, 423, 456, 653, 124]].
odd_numbers = []
для number_list в number_lists:
    для числа в списке чисел:
        если число % 2 == 0:
            odd_numbers.append(number)
print(odd_numbers)
```

- Составление списка:

```
number_lists = [[1, 7, 3, 1], [13, 93, 23, 12], [123, 423, 456, 653, 124]].
odd_numbers = [number for number_list in number_lists for number in number_list if number % 2 == 0]
print(odd_numbers)
```

</b><</details

<details>
<summary>У вас есть следующий список: <code>[{'name': 'Mario', 'food': ['mushrooms', 'goombas']}, {'name': 'Luigi', 'food': ['грибы', 'черепахи']}]</code>
  Извлеките все типы продуктов. Конечный результат должен быть: {'mushrooms', 'goombas', 'turtles'}</summary><br><b>

```
brothers_menu = \
[{'name': 'Mario', 'food': ['mushrooms', 'goombas']}, {'name': 'Luigi', 'food': ['грибы', 'черепахи']}]

# "Классический" способ
def get_food(brothers_menu) -> set:
    temp = []

    для brother в brothers_menu:
        for food in brother['food']:
            temp.append(food)

    return set(temp)

# Один способ (Использование понимания списка)
set([food for bro in x for food in bro['food']])
```
</b><</details

#### Python - Словари

<details>
<summary>Как создать словарь?</summary><br><b>

my_dict = dict(x=1, y=2)
ИЛИ
my_dict = {'x': 1, 'y': 2}
ИЛИ
my_dict = dict([('x', 1), ('y', 2)])
</b><</details

<details>
<summary>Как удалить ключ из словаря?</summary><br><b>

del my_dict['some_key']
вы также можете использовать `my_dict.pop('some_key')`, который возвращает значение ключа.
</b><</details

<details>
<summary>Как отсортировать словарь по значениям?</summary><br><b>

```
{k: v for k, v in sorted(x.items(), key=lambda item: item[1])}
```
</b><</details

<details>
<summary>Как отсортировать словарь по ключам?</summary><br><b>

```
dict(sorted(some_dictionary.items())))
```
</b><</details

<details>
<summary>Как объединить два словаря?</summary><br><b>

```
some_dict1.update(some_dict2)
```
</b><</details


<details>
<summary>Преобразование строки "a.b.c" в словарь <code>{'a': {'b': {'c': 1}}}</code></summary><br><b>

```
выход = {}
string = "a.b.c"
путь = string.split('.')
target = reduce(lambda d, k: d.setdefault(k, {}), path[:-1], output)
цель[путь[-1]] = 1
print(output)
```
</b><</details

##### Реализация общих алгоритмов

<details>
<summary>Вы можете реализовать "бинарный поиск" в Python? </summary><br><b>

[Решение](coding/python/binary_search.py)
</b><</details

#### Файлы Python

<details>
<summary>Как записать в файл?</summary><br><b>

```
with open('file.txt', 'w') as file:
    file.write("Мой проницательный комментарий")
```
</b><</details

<details>
<summary>Как вывести 12-ю строку файла?</summary><br><b>
</b><</details

<details>
<summary>Как развернуть файл? </summary><br><b>
</b><</details

<details>
<summary>Суммирование всех целых чисел в заданном файле</summary><br><b>
</b><</details

<details>
<summary>Печатать случайную строку заданного файла</summary><br><b>
</b><</details

<details>
<summary>Печатать каждую 3-ю строку заданного файла</summary><br><b>
</b><</details

<details>
<summary>Вывод количества строк в заданном файле</summary><br><b>
</b><</details

<details>
<summary>Вывод количества слов в заданном файле</summary><br><b>
</b><</details

<details>
<summary>Можно ли написать функцию, которая выводит все файлы в заданном каталоге, включая подкаталоги</summary><br><b>
</b><</details

<details>
<summary>Запись словаря (переменной) в файл</summary><br><b>

```
импортировать json

with open('file.json', 'w') as f:
    f.write(json.dumps(dict_var))
```
</b><</details

#### Python OS

<details>
<summary>Как вывести текущий рабочий каталог?</summary><br><b>

    импортировать os

    print(os.getcwd())

</b><</details

<details>
<summary>С учетом пути <code>/dir1/dir2/file1</code> выведите имя файла (file1)</summary><br><b>

    импортировать os

    print(os.path.basename('/dir1/dir2/file1'))

    # Другой способ
    print(os.path.split('/dir1/dir2/file1')[1])

</b><</details

<details>
<summary>Данный путь <code>/dir1/dir2/file1</code>

1. Выведите путь без имени файла (/dir1/dir2)
2. Выведите имя каталога, в котором находится файл (dir2)
</summary><br><b>

    импортировать os

    ## Часть 1.
    # os.path.dirname дает путь удаления конечного компонента
    dirpath = os.path.dirname('/dir1/dir2/file1')
    print(dirpath)

    ## Часть 2.
    print(os.path.basename(dirpath))

</b><</details

<details>
<summary>Как выполнять команды командной оболочки с помощью Python?</summary><br><b>
</b><</details

<details>
<summary>Как объединить компоненты пути? Например, <code>/home</code> и <code>luig</code> приведут к <code>/home/luigi</code> </summary><br><b>
</b><</details

<details>
<summary>Как удалить непустой каталог?</summary><br><b>
</b><</details

#### Python Regex

<details>
<summary>Как в Python выполнять операции, связанные с регулярными выражениями? (сопоставление шаблонов, замена строк и т.д.) </summary><br><b>

Использование модуля re
</b><</details

<details>
<summary>Как заменить строку "зеленый" на "синий"?</summary><br><b>
</b><</details

<details>
<summary>Как найти все IP-адреса в переменной? Как найти их в файле? </summary><br><b>
</b><</details

#### Строки Python

<details>
<summary>Найти первый повторяющийся символ в строке</summary><br><b>

Пока вы перебираете символы, храните их в словаре и проверяете для каждого символа, есть ли он уже в словаре.

```
def firstRepeatedCharacter(str):
    chars = {}
    для ch в str:
        если ch в chars:
            возвращать ch
        еще:
            chars[ch] = 0
```
</b><</details

<details>
<summary>Как извлечь уникальные символы из строки? Например, если ввести "itssssssameeeemarioooooo", то на выходе будет "mrtisaoe"</summary><br><b>

```
x = "егоссамеееемариоооо"
y = ''.join(set(x))
```
</b><</details

<details>
<summary>Найти все перестановки заданной строки</summary><br><b>

```
def permute_string(string):

    если len(string) == 1:
        return [string]

    перестановки = []
    for i in range(len(string)):
        swaps = permute_string(string[:i] + string[(i+1):])
        для свопа в свопах:
            permutations.append(string[i] + swap)

    возвращать перестановки

print(permute_string("abc"))
```

Короткий способ (но, вероятно, неприемлемый на собеседованиях):

```
from itertools import permutations

[''.join(p) for p in permutations("abc")]
```

Подробный ответ можно найти здесь: http://codingshell.com/python-all-string-permutations

</b><</details

<details>
<summary>Как проверить, содержит ли строка вложенную строку?</summary><br><b>
</b><</details

<details>
<summary>Найти частоту каждого символа в строке</summary><br><b>
</b><</details

<details>
<summary>Посчитать количество пробелов в строке</summary><br><b>

Вы можете использовать метод "count" следующим образом:

python

ImAString.count(" ")

</b><</details

<details>
<summary>Для заданной строки найдите N наиболее повторяющихся слов</summary><br><b>
</b><</details

<details>
<summary>Для строки (которая представляет матрицу) "1 2 3\n4 5 6\n7 8 9" создайте переменные rows и colums (должны содержать целые числа, а не строки)</summary><br><b>
</b><</details

<details>
<summary>Каков результат каждого из следующих действий?

```
>> ', '.join(["Один", "Два", "Три"])
>> " ".join("welladsadgadoneadsadga".split("adsadga")[:2])
>> "".join(["c", "t", "o", "a", "o", "q", "l"])[0::2]
```
</summary><br><b>

```
 'One, Two, Three'
 "молодец
 'cool'
```
</b><</details

<details>
<summary>Если <code>x = "pizza"</code>, то каким будет результат <code>x[::-1]</code>?</summary><br><b>

Он перевернет строку, так что x будет равен `azzip`.
</b><</details

<details>
<summary>Пересмотрите каждое слово в строке (сохраняя порядок)</summary><br><b>
</b><</details

<details>
<summary>Каков вывод следующего кода: <code>"".join(["a", "h", "m", "a", "h", "a", "n", "q", "r", "l", "o", "i", "f", "o", "o"])[2::3]</code></summary><br><b>

марио
</b><</details

#### Итераторы Python

<details>
<summary>Что такое итератор?</summary><br><b>
</b><</details

#### Python Misc

<details>
<summary>Объяснение сериализации данных и как ее выполнить в Python</summary><br><b>
</b><</details

<details>
<summary>Как обрабатывать разбор аргументов в Python?</summary><br><b>
</b><</details

<details>
<summary>Что такое генератор? Зачем нужны генераторы? </summary><br><b>
</b><</details

<details>
<summary>Каким будет вывод следующего блока?

```
for i in range(3, 3):
   print(i)
```
</summary><br><b>

Выхода нет :)
</b><</details

<details>
<summary>Что такое <code>yeild</code>? Когда вы будете его использовать? </summary><br><b>
</b><</details

<details>
<summary>Объясняет следующие типы методов и как их использовать:

  * Статический метод
  * Метод класса
  * метод экземпляра</summary><br><b>
</b><</details

<details>
<summary>Как развернуть список?</summary><br><b>
</b><</details

<details>
<summary>Как объединить список строк в одну строку с пробелами между строками</summary><br><b>
</b><</details

<details>
<summary>У вас есть следующий список вложенных списков: <code>[['Mario', 90], ['Geralt', 82], ['Gordon', 88]]</code> Как отсортировать список по номерам во вложенных списках? </code></summary><br><b>

Один из способов:

the_list.sort(key=lambda x: x[1])
</b><</details

<details>
<summary>Объясните следующее:

  * zip()
  * map()
  * filter()</summary><br><b>
</b><</details

#### Python - нарезка

Для следующих упражнений по нарезке предположим, что у вас есть следующий список: `my_list = [8, 2, 1, 10, 5, 4, 3, 9]`.

<details>
<summary>Что является результатом `my_list[0:4]`? </summary><br><b>
</b><</details

<details>
<summary>Что является результатом `my_list[5:6]`? </summary><br><b>
</b><</details

<details>
<summary>Что является результатом `my_list[5:5]`? </summary><br><b>
</b><</details

<details>
<summary>Что является результатом `my_list[::-1]`? </summary><br><b>
</b><</details

<details>
<summary>Что является результатом `my_list[::3]`? </summary><br><b>
</b><</details

<details>
<summary>Что является результатом `my_list[2:]`? </summary><br><b>
</b><</details

<details>
<summary>Что является результатом `my_list[:3]`? </summary><br><b>
</b><</details

#### Отладка Python

<details>
<summary>Как отлаживать код Python?</summary><br><b>

pdb :D
</b><</details

<details>
<summary>Как проверить, сколько времени ушло на выполнение определенного скрипта или блока кода?</summary><br><b>
</b><</details

<details>
<summary>Что возвращает пустой <code>return</code>? </summary><br><b>
</b>

Короткий ответ: он возвращает объект None.

Мы можем пойти немного глубже и объяснить разницу между

```
def a ():
    возврат

 Нет
```

И

```
def a ():
    пройти

 Нет
```
Или нам могут задать это как следующий вопрос, поскольку оба они дают один и тот же результат.

Мы можем использовать модуль dis, чтобы посмотреть, что происходит:

```
  2 0 LOAD_CONST 0 (<объект кода a по адресу 0x0000029C4D3C2DB0, файл "<dis>", строка 2>)
              2 LOAD_CONST 1 ('a')
              4 MAKE_FUNCTION 0
              6 STORE_NAME 0 (a)

  5 8 LOAD_CONST 2 (<объект кода b по адресу 0x0000029C4D3C2ED0, файл "<dis>", строка 5>)
             10 LOAD_CONST 3 ('b')
             12 MAKE_FUNCTION 0
             14 STORE_NAME 1 (b)
             16 LOAD_CONST 4 (Нет)
             18 RETURN_VALUE

Разборка <объекта кода a по адресу 0x0000029C4D3C2DB0, файл "<dis>", строка 2>:
  3 0 LOAD_CONST 0 (нет)
              2 RETURN_VALUE

Разборка <объекта кода b по адресу 0x0000029C4D3C2ED0, файл "<dis>", строка 5>:
  6 0 LOAD_CONST 0 (нет)
              2 RETURN_VALUE
```

Пустой <code> return</code> точно такой же, как <code>return None</code> и функции без явного возврата.
всегда будет возвращать None независимо от операций, поэтому


```
def sum(a, b):
    глобальный к
    c = a + b

 Нет
```
</b><</details

<details>
<summary>Как улучшить следующий блок кода?

```
li = []
for i in range(1, 10):
    li.append(i)
```
</summary><br><b>

```
[i for i in range(1, 10)]
```
</b><</details

<details>
<summary>С учетом следующей функции

```
def is_int(num):
    if isinstance(num, int):
        print('Yes')
    еще:
        print('No')
```
Каков будет результат работы is_int(2) и is_int(False)?
</summary><br><b>
</b><</details

#### Python - Связанный список

<details>
<summary>Вы можете реализовать связный список в Python? </summary><br><b>

Причина, по которой нам нужно реализовать это в первую очередь, заключается в том, что связный список не является частью стандартной библиотеки Python.<br>
Чтобы реализовать связанный список, мы должны реализовать две структуры: Сам связанный список и узел, который используется связанным списком.

Начнем с узла. Узел имеет некоторое значение (данные, которые он хранит) и указатель на следующий узел

```
class Node(object):
    def __init__(self, data):
        self.data = data
        self.next = None
```

Теперь о связном списке. Пустой связный список не имеет ничего, кроме пустой головы.

```
class LinkedList(object):
    def __init__(self):
        self.head = None
```

Теперь мы можем начать использовать связанный список

```
ll = Linkedlist()
ll.head = Node(1)
ll.head.next = Node(2)
ll.head.next.next = Node(3)
```

Что мы имеем:

---- ----- ----
| 1 | -> | 2 | -> | 3 |
---- ----- -----

Обычно реализуется больше методов, например, метод push_head(), который вставляет узел в начало связанного списка

```
def push_head(self, value):
    new_node = Node(value)
    new_node.next = self.head
    self.head = new_node
```
</b><</details

<details>
<summary>Добавьте метод в класс Linked List для обхода (печати данных каждого узла) связанного списка</summary><br><b>

def print_list(self):
    узел = self.head
    while(node):
        print(node.data)
        node = node.next
</b><</details

<details>
<summary>Напишите метод, который будет возвращать булево значение в зависимости от того, есть ли цикл в связанном списке или нет</summary><br><b>

Давайте воспользуемся алгоритмом поиска циклов Флойда:

```
def loop_exists(self):
    one_step_p = self.head
    two_steps_p = self.head
    while(one_step_p и two_steps_p и two_steps_p.next):
        one_step_p = self.head.next
        two_step_p = self.head.next.next
        если (один_шаг_p == два_шага_p):
            вернуть True 
    вернуть False
```
</b><</details

#### Python - Stack

<details>
<summary>Реализация стека в Python</summary><br><b>
</b><</details

#### Тестирование на Python

<details>
<summary>Какой у вас опыт написания тестов на Python? </summary><br><b>
</b><</details

<details>
<summary>Что такое PEP8? Приведите пример 3 руководящих принципов стиля</summary><br><b>

PEP8 - это список соглашений по кодированию и руководящих принципов стиля для Python

5 рекомендаций по стилю:

    1. Ограничьте все строки максимум 79 символами.
    2. Обведите определения функций и классов верхнего уровня двумя пустыми строками.
    3. Используйте запятые, когда составляете кортеж из одного элемента
    4. Используйте пробелы (а не табуляцию) для отступов
    5. Используйте 4 пробела на каждый уровень отступа
</b><</details

<details>
<summary>Как проверить, было ли поднято исключение?</summary><br><b>
</b><</details

<details>
<summary>Что <code>assert</code> делает в Python? </summary><br><b>
</b><</details

<details>
<summary>Объяснение имитаторов</summary><br><b>
</b><</details

<details>
<summary>Как измерить время выполнения небольших фрагментов кода?</summary><br><b>
</b><</details

<details>
<summary>Почему не следует использовать <code>assert</code> в нетестовом/производственном коде?</summary><br><b>
</b><</details

#### Фляга

<details>
<summary>Можете ли вы описать, что такое Django/Flask и как вы его использовали? Почему именно Flask, а не Django? (или наоборот)</summary><br><b>
</b><</details

<details>
<summary>Что такое маршрут? </summary><br><b>
Как и любой веб-фреймворк, Flask предоставляет функцию маршрутизации, которая позволяет вам обслуживать содержимое заданного URL.

В Python существует несколько способов сопоставить URL с функцией.

- Декоратор: вы можете использовать декораторы python. В данном случае мы используем `app`. Этот декоратор `app` является экземпляром класса `Flask`. А маршрут - это метод этого класса.

```
@app.route('/')
def home():
  return 'основной сайт'
```

- Метод `add_url_rule`: Это метод класса Flask. Мы также можем использовать его для сопоставления URL с функцией.

```
def home():
  return 'основной сайт'

app.add_url_rule('/', view_func=home)
```

</b><</details

<details>
<summary>Что такое чертеж во Flask? </summary><br><b>
</b><</details

<details>
<summary>Что такое шаблон? </summary><br><b>
</b><</details

#### zip

<details>
<summary>Для <code>x = [1, 2, 3]</code>, каков результат list(zip(x))? </summary><br><b>

```
[(1,), (2,), (3,)]
```
</b><</details

<details>
<summary>Каков результат каждого из следующих действий:

```
list(zip(range(5), range(50), range(50)))
list(zip(range(5), range(50), range(-2)))
```
</summary><br><b>

```
[(0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4)]
[]
```
</b><</details

#### Дескрипторы Python

<details>
<summary>Объяснить дескрипторы</summary><br><b>

Читайте о дескрипторах [здесь](https://docs.python.org/3/howto/descriptor.html)
</b><</details

<details>
<summary>Каким будет результат выполнения <code>a.num2</code> при использовании следующего кода

```
класс B:
    def __get__(self, obj, objtype=None):
        повторный возврат 10

класс A:
    num1 = 2
    num2 = 5()
```
</summary><br><b>
10
</b><</details

<details>
<summary>Каким будет результат выполнения <code>some_car = Car("Red", 4)</code> при использовании следующего кода

```
класс Печать:

    def __get__(self, obj, objtype=None):
        значение = obj._color
        print("Цвет был установлен на {}".format(valie))
        возвращаемое значение

    def __set__(self, obj, value):
        print("Цвет автомобиля - {}".format(value))
        obj._color = значение

класс Кар:

    цвет = Print()

    def __ini__(self, color, age):
        self.color = color
        self.age = age
```
</summary><br><b>
Будет создан экземпляр класса Car и выведено следующее: "Цвет автомобиля - красный".
</b><</details

#### Python Misc

<details>
<summary>Как породить несколько процессов в Python? </summary><br><b>
</b><</details

<details>
<summary>Реализация простого калькулятора для двух чисел</summary><br><b>

```
def add(num1, num2):
    вернуть num1 + num2


def sub(num1, num2):
    вернуть num1 - num2


def mul(num1, num2):
    возврат num1*num2


def div(num1, num2):
    возврат num1 / num2

операторы = {
    '+': добавить,
    '-': sub,
    '*': mul,
    '/': div
}

if __name__ == '__main__':
    operator = str(input("Оператор: "))
    num1 = int(input("1-е число: "))
    num2 = int(input("2-е число: "))
    print(operators[operator](num1, num2))
```
</b><</details

<details>
<summary>С какими типами данных вы знакомы, которые не являются встроенными типами Python, но все же предоставляются модулями, которые являются частью стандартной библиотеки?</summary><br><b>

Это хорошая ссылка https://docs.python.org/3/library/datatypes.html
</b><</details

<details>
<summary>Объясните, что такое декоратор</summary><br><b>
</b>
<b>В python все является объектом, даже сами функции. Поэтому вы можете передавать функции в качестве аргументов
для другой функции, например;

```
def wee(word):
    возвращать слово

def oh(f):
    return f + "Ohh"

 oh(wee("Wee"))
<<< Wee Ohh
```

Это позволяет нам контролировать предшествующее выполнение любой заданной функции и если мы добавили другую функцию в качестве обертки,
(функция, получающая другую функцию, которая получает функцию в качестве параметра) мы также можем контролировать выполнение после выполнения.

Иногда мы хотим контролировать до-после выполнения многих функций, и писать их становится утомительно.

<code> f = function(function_1())</code>
<code> f = function(function_1(function_2(*args)))</code>

каждый раз, вот что делают декораторы, они вводят синтаксис для записи всего этого на ходу, используя ключевое слово '@'.
</b>
<</details

<details>
<summary>Вы можете показать, как писать и использовать декораторы? </summary><br><b>

<code>
Эти два декоратора (ntimes и timer) обычно используются для отображения функциональных возможностей декораторов, их можно найти во многих
tutorials/reviews. Впервые я увидел эти примеры два года назад в pyData 2017. https://www.youtube.com/watch?v=7lmCu8wz8ro&t=3731s</code>.

```
Простой декоратор:

def deco(f):
    print(f "Привет, я функция {f.__name__}()!")
    возвращать f

@deco
def hello_world():
    return "Привет, я в игре!".

a = hello_world()
print(a)

 Привет я функция hello_world()!
    Привет, я участвую!
```

Это самый простой вариант декоратора, он избавляет нас от необходимости писать <code>a = deco(hello_world())</code>.
Но на данный момент мы можем контролировать только выполнение "до", давайте займемся "после":

```
def deco(f):
    def wrapper(*args, **kwargs):
        print("Рик Санчес!").
        func = f(*args, **kwargs)
        print("Я в деле!").
        return func
    возвращать обёртку

@deco
def f(word):
    print(word)

a = f("************")
 Рик Санчес!
    ************
    Я в деле!
```

deco получает функцию -> f
обертка получает аргументы -> *args, **kwargs

обертка возвращает функцию плюс аргументы -> f(*args, **kwargs)
деко возвращает обертку.

Как видите, нам удобно делать что-то до и после выполнения данной функции.

Например, мы можем написать декоратор, который вычисляет время выполнения функции.

```
время импорта
def deco(f):
    def wrapper(*args, **kwargs):
        before = time.time()
        func = f(*args, **kwargs)
        after = time.time()
        print(after-before)
        return func
    возвращать обёртку

@deco
def f():
    time.sleep(2)
    print("************")

a = f()
 2.0008859634399414
```

Или создайте декоратор, который выполняет функцию n раз.

```
def n_times(n):
    def wrapper(f):
        def inner(*args, **kwargs):
            for _ in range(n):
                func = f(*args, **kwargs)
            return func
        вернуть внутренний
    возвращать обёртку

@n_times(4)
def f():
    print("************")

a = f()

************
   ************
   ************
   ************
```

</b><</details

<details>
<summary>Напишите декоратор, который вычисляет время выполнения функции</summary><br><b>
</b><</details

<details>
<summary>Напишите сценарий, который будет определять, доступен ли данный хост на данном порту</summary><br><b>
</b><</details

<details>
<summary>Вы знакомы с классами данных? Можете ли вы объяснить, для чего они используются? </summary><br><b>
</b><</details

<details>
<summary>Вы написали класс для представления автомобиля. Как бы вы сравнили два экземпляра автомобиля, если два автомобиля равны, если у них одинаковая модель и цвет? </summary><br><b>

```
класс Кар:
    def __init__(self, model, color):
        self.model = model
        self.color = color

    def __eq__(self, other):
        if not isinstance(other, Car):
            return NotImplemented
        return self.model == other.model and self.color == other.color

>> a = Car('model_1', 'red')
>> b = Car('model_2', 'green')
>> c = Car('model_1', 'red')
>> a == b
Ложь
>> a == c
Правда
```
</b><</details

<details>
<summary>Объяснение контекстного менеджера</summary><br><b>
</b><</details

<details>
<summary>Расскажите мне все, что вы знаете о параллелизме в Python</summary><br><b>
</b><</details

<details>
<summary>Объяснение протокола буфера</summary><br><b>
</b><</details

<details>
<summary>У вас есть опыт работы с веб-скрейпингом? Можете ли вы описать, что вы использовали и для чего? </summary><br><b>
</b><</details

<details>
<summary>Вы можете реализовать команду Linux <code>tail</code> в Python? Бонус: также реализовать <code>head</code></summary><br><b>
</b><</details

<details>
<summary>Вы создали веб-страницу, на которой пользователь может загрузить документ. Но функция, которая считывает загруженные файлы, выполняется долго, в зависимости от размера документа, и пользователю приходится ждать завершения операции чтения, прежде чем он сможет продолжить работу с сайтом. Как можно решить эту проблему? </summary><br><b>
</b><</details

<details>
<summary>Как именно работает доходность?</summary><br><b>
</b><</details

## Мониторинг

<details>
<summary>Объяснение мониторинга. Что это такое? Какова его цель? </summary><br><b>

Google: "Мониторинг является одним из основных средств, с помощью которых владельцы сервисов следят за состоянием и доступностью системы".
</b><</details

<details>
<summary>Что не так со старым подходом, когда нужно следить за определенным значением и запускать оповещение по электронной почте/телефону при превышении значения? </summary><br><b>

Такой подход требует от человека постоянно проверять, почему значение превышено и как с этим справиться, в то время как сегодня более эффективно уведомлять людей только тогда, когда им нужно предпринять фактическое действие.
Если проблема не требует вмешательства человека, то она может быть устранена некоторыми процессами, запущенными в соответствующей среде.
</b><</details

<details>
<summary>Какие типы выходных данных мониторинга вам знакомы и/или использовались в прошлом?</summary><br><b>

Оповещения<br>
Билеты<br>
Ведение журнала<br>
</b><</details

<details>
<summary>В чем разница между мониторингом инфраструктуры и мониторингом приложений? (методы, инструменты, ...)</summary><br><b>
</b><</details

## Prometheus

<details>
<summary>Что такое Прометей? Каковы некоторые из основных особенностей Prometheus? </summary><br><b>
</b></details>>

<details>
<summary>В каких сценариях лучше НЕ использовать Prometheus?</summary><br><b>

Из документации Prometheus: "если вам нужна 100% точность, например, для выставления счетов за каждый запрос".
</b></details>>

<details>
<summary>Описание архитектуры и компонентов Prometheus</summary><br><b>
</b></details>>

<details>
<summary>Вы можете сравнить Prometheus с другими решениями, такими как InfluxDB, например?</summary><br><b>
</b></details>>

<details>
<summary>Что такое оповещение? </summary><br><b>
</b></details>>

<details>
<summary>Описание следующих компонентов Prometheus:

  * Сервер "Прометей
  * Push Gateway
  * Менеджер оповещений</summary><br><b>

Сервер Prometheus отвечает за сбор и хранение данных<br>.
Push-шлюз используется для кратковременных заданий<br>.
Менеджер оповещений отвечает за оповещения ;)
</b></details>>

<details>
<summary>Что такое экземпляр? Что такое работа? </summary><br><b>
</b></details>>

<details>
<summary>Какие основные типы метрик поддерживает Prometheus?</summary><br><b>
</b></details>>

<details>
<summary>Что такое экспортер? Для чего он используется? </summary><br><b>
</b></details>>

<details>
<summary>С какими передовыми практиками Prometheus вы знакомы? Назовите хотя бы три</summary><br><b>
</b></details>>

<details>
<summary>Как получить общее количество запросов за определенный период времени?</summary><br><b>
</b></details>>

<details>
<summary>Что означает HA в "Прометее"? </summary><br><b>
</b></details>>

<details>
<summary>Как объединить две метрики?</summary><br><b>
</b></details>>

<details>
<summary>Как написать запрос, который возвращает значение метки?</summary><br><b>
</b></details>>

<details>
<summary>Как преобразовать cpu_user_seconds в использование процессора в процентах?</summary><br><b>
</b></details>>

## Go

<details>
<summary>Каковы некоторые особенности языка программирования Go?</summary><br><b>

  * Сильная и статическая типизация - тип переменных не может быть изменен с течением времени, и они должны быть определены во время компиляции.
  * Простота
  * Быстрое время компиляции
  * Встроенный параллелизм
  * Сборка мусора
  * Независимость от платформы
  * Компиляция в отдельный двоичный файл - все, что вам нужно для запуска вашего приложения, будет скомпилировано в один двоичный файл. Очень полезно для управления версиями во время выполнения.

Go также имеет хорошее сообщество.
</b></details>>

<details>
<summary>В чем разница между <code>var x int = 2</code> и <code>x := 2</code>?</summary><br><b>

Результат тот же - переменная со значением 2.

С помощью <code>var x int = 2</code> мы устанавливаем тип переменной как целое число, а с помощью <code>x := 2</code> мы позволяем Go самостоятельно определить тип.
</b></details>>

<details>
<summary>Истина или ложь? В Go мы можем повторно объявлять переменные, а после объявления мы должны их использовать.</summary>.

Ложь. Мы не можем повторно объявлять переменные, но да, мы должны использовать объявленные переменные.
</b></details>>

<details>
<summary>Какие библиотеки Go вы использовали? </summary><br><b>

Ответ на этот вопрос должен быть основан на вашем использовании, но некоторые примеры таковы:

  * fmt - форматированный ввод-вывод
</b></details>>

<details>
<summary>В чем проблема следующего блока кода? Как его исправить?

```
func main() {
    var x float32 = 13.5
    var y int
    y = x
}
```
</summary><br><b>
</b></details>>

<details>
<summary>Следующий блок кода пытается преобразовать целое число 101 в строку, но вместо этого мы получаем "e". Почему так происходит? Как это исправить?

```
основной пакет

импортировать "fmt"

func main() {
    var x int = 101
    var y string
    y = string(x)
    fmt.Println(y)
}
```
</summary><br><b>

Он смотрит, какое значение юникода установлено в 101, и использует его для преобразования целого числа в строку.
Если вы хотите получить "101", вам следует использовать пакет "strconv" и заменить <code>y = string(x)</code> на <code>y = strconv.Itoa(x)</code>.
</b></details>>

<details>
<summary>Что не так со следующим кодом?

```
основной пакет

func main() {
    var x = 2
    var y = 3
    const someConst = x + y
}
```
</summary><br><b>

Константы в Go могут быть объявлены только с помощью выражений констант.
Но `x`, `y` и их сумма являются переменными.
<br>
<code>const инициализатор x + y не является константой</code>
</b></details>>

<details>
<summary>Каким будет вывод следующего блока кода?

```
основной пакет

импортировать "fmt"

const (
	x = йота
	y = йота
)
const z = iota

func main() {
	fmt.Printf("%v\n", x)
	fmt.Printf("%v\n", y)
	fmt.Printf("%v\n", z)
}
```
</summary><br><b>

Идентификатор iota в Go используется в объявлениях const для упрощения определений увеличивающихся чисел. Поскольку его можно использовать в выражениях, он обеспечивает универсальность, превосходящую возможности простых перечислений.
<br>
`x` и `y` в первой йота-группе, `z` во второй.
<br>
[страница Iota в Go Wiki](https://github.com/golang/go/wiki/Iota)
</b></details>>

<details>
<summary>Для чего используется _ в Go?</summary><br><b>

Это избавляет от необходимости объявлять все переменные для возвращаемых значений.
Он называется [пустой идентификатор](https://golang.org/doc/effective_go.html#blank).
<br>
[ответ в СЦ] (https://stackoverflow.com/questions/27764421/what-is-underscore-comma-in-a-go-declaration#answer-27764432)
</b></details>>

<details>
<summary>Каким будет вывод следующего блока кода?

```
основной пакет

импортировать "fmt"

const (
	_ = йота + 3
	x
)

func main() {
	fmt.Printf("%v\n", x)
}
```
</summary><br><b>

Поскольку первая йота объявлена со значением `3` (`+3`), следующая имеет значение `4`.
</b></details>>

<details>
<summary>Каким будет вывод следующего блока кода?

```
основной пакет

импорт (
	"fmt"
	"синхронизация"
	"время"
)

func main() {
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		time.Sleep(time.Second * 2)
		fmt.Println("1")
		wg.Done()
	}()

	go func() {
		fmt.Println("2")
	}()

	wg.Wait()
	fmt.Println("3")
}
```
</summary><br><b>

Выход: 2 1 3

[Aritcle о sync/waitgroup](https://tutorialedge.net/golang/go-waitgroup-tutorial/)

[Golang package sync](https://golang.org/pkg/sync/)
</b></details>>

<details>
<summary>Каким будет вывод следующего блока кода?

```
основной пакет

импорт (
	"fmt"
)

func mod1(a []int) {
	для i := диапазон a {
		a[i] = 5
	}

	fmt.Println("1:", a)
}

func mod2(a []int) {
	a = append(a, 125) // !

	для i := диапазон a {
		a[i] = 5
	}

	fmt.Println("2:", a)
}

func main() {
	s1 := []int{1, 2, 3, 4}
	mod1(s1)
	fmt.Println("1:", s1)

	s2 := []int{1, 2, 3, 4}
	mod2(s2)
	fmt.Println("2:", s2)
}
```
</summary><br><b>

Выходные данные: <code><br>
1 [5 5 5 5]<br>
1 [5 5 5 5]<br>
2 [5 5 5 5 5]<br>
2 [1 2 3 4]<br>
</code>

В `mod1` a является ссылкой, и когда мы используем `a[i]`, мы изменяем значение `s1` на.
Но в `mod2`, `append` создает новый срез, и мы изменяем только значение `a`, а не `s2`.

[Aritcle about arrays](https://golangbot.com/arrays-and-slices/),
[Запись в блоге о `append`](https://blog.golang.org/slices)
</b></details>>

<details>
<summary>Каким будет вывод следующего блока кода?

```
основной пакет

импорт (
	"container/heap"
	"fmt"
)

// IntHeap - это мини-куча целых чисел.
тип IntHeap []int

func (h IntHeap) Len() int { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
	// Push и Pop используют приемники указателей, потому что они изменяют длину фрагмента,
	// а не только его содержимое.
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	старый := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	возвращать x
}

func main() {
	h := &IntHeap{4, 8, 3, 6}
	heap.Init(h)
	heap.Push(h, 7)

  fmt.Println((*h)[0])
}
```
</summary><br><b>

Выход: 3

[Golang container/heap package](https://golang.org/pkg/container/heap/)
</b></details>>

## Mongo

<details>
<summary>Каковы преимущества MongoDB? Или, другими словами, почему стоит выбрать именно MongoDB, а не другую реализацию NoSQL? </summary><br><b>

Преимущества MongoDB заключаются в следующем:
- Бессхемный
- Легко масштабируется
- Отсутствие сложных соединений
- Структура отдельного объекта ясна

</b></details>>

<details>
<summary>В чем разница между SQL и NoSQL? </summary><br><b>

Основное отличие заключается в том, что базы данных SQL являются структурированными (данные хранятся в виде
таблицы со строками и столбцами - как таблица электронной таблицы excel), в то время как NoSQL - это
неструктурированные, и хранение данных может варьироваться в зависимости от того, как настроена СУБД NoSQL, например
как пары ключ-значение, ориентированные на документы и т.д.
</b></details>>

<details>
<summary>В каких сценариях вы бы предпочли использовать NoSQL/Mongo вместо SQL?</summary><br><b>

  * Гетерогенные данные, которые часто меняются
  * Согласованность и целостность данных не является главным приоритетом
  * Лучше всего подходит, если база данных должна быстро масштабироваться
</b></details>>

<details>
<summary>Что такое документ? Что такое коллекция? </summary><br><b>
</b></details>>

<details>
<summary>Что такое агрегатор? </summary><br><b>
</b></details>>

<details>
<summary>Что лучше? Встроенные документы или документы со ссылками? </summary><br><b>
</b></details>>

<details>
<summary>Вы выполняли оптимизацию поиска данных в Mongo? Если нет, можете ли вы подумать о том, как оптимизировать медленное получение данных? </summary><br><b>
</b></details>>

##### Запросы

<details>
<summary>Поясните этот запрос: <code>db.books.find({"name": /abc/})</code></summary><br><b>
</b></details>>

<details>
<summary>Поясните этот запрос: <code>db.books.find().sort({x:1})</code></summary><br><b>
</b></details>>

<details>
<summary>В чем разница между find() и find_one()?</code></summary><br><b>
</b></details>>

<details>
<summary>Как можно экспортировать данные из Mongo DB?</code></summary><br><b>

* mongoexport
* языки программирования
</b></details>>

## SQL

### Упражнения по SQL

|Name|Topic|Objective & Instructions|Solution|Comments|
|--------|--------|------|----|----|
| Функции против сравнений | Улучшение запросов | [Упражнение](exercises/sql/improve_query.md) | [Решение](exercises/sql/solutions/improve_query.md)

### Самооценка SQL

<details>
<summary>Что такое SQL? </summary><br><b>

SQL (Structured Query Language) - это стандартный язык для реляционных баз данных (таких как MySQL, MariaDB, ...).<br>
Он используется для чтения, обновления, удаления и создания данных в реляционной базе данных.
</b></details>>

<details>
<summary>Как SQL отличается от NoSQL</summary><br><b>

Основное отличие заключается в том, что базы данных SQL являются структурированными (данные хранятся в виде
таблицы со строками и столбцами - как таблица электронной таблицы excel), в то время как NoSQL - это
неструктурированные, и хранение данных может варьироваться в зависимости от того, как настроена СУБД NoSQL, например
как пары ключ-значение, ориентированные на документы и т.д.
</b></details>>

<details>
<summary>Когда лучше использовать SQL? NoSQL? </summary><br><b>

SQL - лучше всего использовать, когда целостность данных имеет решающее значение. SQL обычно реализуется с помощью многих
предприятий и областей в сфере финансов благодаря соответствию ACID.

NoSQL - отлично подходит для быстрого масштабирования. NoSQL был разработан для веб-приложений
в виду, поэтому он отлично подходит, если вам нужно быстро распространить одну и ту же информацию среди
несколько серверов

Кроме того, поскольку NoSQL не придерживается строгой структуры таблицы со столбцами и строками.
что требуется реляционным базам данных, вы можете хранить различные типы данных вместе.
</b></details>>

##### Практический SQL - основы

Для этих вопросов мы будем использовать таблицы Customers и Orders, показанные ниже:

**Клиенты**.

Customer_ID | Customer_Name | Items_in_cart | Cash_spent_to_Date
------------ | ------------- | ------------- | -------------
100204 | Джон Смит | 0 | 20.00
100205 | Джейн Смит | 3 | 40.00
100206 | Бобби Франк | 1 | 100.20

**ОРДЕРЫ**

Customer_ID | Order_ID | Item | Price | Date_sold
------------ | ------------- | ------------- | ------------- | -------------
100206 | A123 | Rubber Ducky | 2.20 | 2019-09-18
100206 | A123 | Пенная ванна | 8.00 | 2019-09-18
100206 | Q987 | 80-Pack TP | 90.00 | 2019-09-20
100205 | Z001 | Корм для кошек - рыба-тунец | 10.00 | 2019-08-05
100205 | Z001 | Корм для кошек - курица | 10.00 | 2019-08-05
100205 | Z001 | Корм для кошек - говядина | 10.00 | 2019-08-05
100205 | Z001 | Корм для кошек - Кесадилья для котят | 10.00 | 2019-08-05
100204 | X202 | Кофе | 20.00 | 2019-04-29

<details>
<summary>Как мне выбрать все поля из этой таблицы?</summary><br><b>

Выберите * <br>
От клиентов;
</b></details>>

<details>
<summary>Сколько товаров находится в корзине Джона?</summary><br><b>

Выберите Items_in_cart <br>
От клиентов <br>
Где Имя_клиента = "Джон Смит";
</b></details>>

<details>
<summary>Какова сумма всех денежных средств, потраченных всеми клиентами?</summary><br><b>

Select SUM(Cash_spent_to_Date) as SUM_CASH <br>
От клиентов;
</b></details>>

<details>
<summary>Сколько человек имеют товары в корзине?</summary><br><b>

Select count(1) as Number_of_People_w_items <br>
От клиентов <br>
где Items_in_cart > 0;
</b></details>>

<details>
<summary>Как присоединить таблицу customer к таблице order? </summary><br><b>

Вы объедините их по уникальному ключу. В данном случае уникальным ключом является Customer_ID в
как в таблице "Клиенты", так и в таблице "Заказы
</b></details>>

<details>
<summary>Как показать, какой клиент заказал какие товары? </summary><br><b>

Select c.Customer_Name, o.Item <br>
От клиентов c <br>
Left Join Orders o <br>
  On c.Customer_ID = o.Customer_ID;

</b></details>>

<details>
<summary>Используя оператор with, как бы вы показали, кто заказал кошачий корм и общую сумму потраченных денег?</summary><br><b>

with cat_food as ( <br>
Select Customer_ID, SUM(Price) as TOTAL_PRICE <br>
Из приказов <br>
Where Item like "%Cat Food%" <br>
Группировать по идентификатору клиента (Customer_ID) <br>
) <br>
Выберите Имя_клиента, ИТОГО_ЦЕНА <br>
От клиентов c <br>
Inner JOIN cat_food f <br>
  ON c.Customer_ID = f.Customer_ID <br>
where c.Customer_ID in (Select Customer_ID from cat_food);

Хотя это было простое утверждение, оговорка "с" действительно сияет, когда
необходимо выполнить сложный запрос к одной таблице, прежде чем соединить ее с другой. Операторы With очень удобны,
потому что вы создаете псевдо временную таблицу при выполнении запроса, вместо того чтобы создавать совершенно новую таблицу.

Сумма всех покупок кошачьего корма не была легко доступна, поэтому мы использовали оператор with, чтобы создать
псевдотаблицу, чтобы получить сумму цен, потраченных каждым покупателем, затем присоединитесь к таблице обычным образом.
</b></details>>

<details>
<summary>Какой из следующих запросов вы бы использовали?

```
SELECT count(*) SELECT count(*)
FROM shawarma_purchases FROM shawarma_purchases
ЧТО против ЧЕГО
  YEAR(purchased_at) == '2017' purchased_at >= '2017-01-01' AND
                                            purchased_at <= '2017-31-12'
```
</summary><br><b>

```
SELECT count(*)
FROM шаурма_покупки
ГДЕ
  purchased_at >= '2017-01-01' AND
  purchased_at <= '2017-31-12'
```

Когда вы используете функцию (`YEAR(purchased_at)`), ей приходится сканировать всю базу данных, в отличие от использования индексов и в основном столбца как он есть, в его естественном состоянии.
</b></details>>

## Azure

<details>
<summary>Что такое Azure Portal? </summary><br><b>

[Microsoft Docs](https://docs.microsoft.com/en-us/learn/modules/intro-to-azure-fundamentals/what-is-microsoft-azure): "Портал Azure - это унифицированная веб-консоль, которая является альтернативой инструментам командной строки. С помощью портала Azure вы можете управлять своей подпиской Azure с помощью графического интерфейса пользователя."
</b></details>>

<details>
<summary>Что такое Azure Marketplace? </summary><br><b>

[Microsoft Docs](https://docs.microsoft.com/en-us/learn/modules/intro-to-azure-fundamentals/what-is-microsoft-azure): "Azure marketplace помогает соединить пользователей с партнерами Microsoft, независимыми поставщиками программного обеспечения и стартапами, которые предлагают свои решения и услуги, оптимизированные для работы на Azure".
</b></details>>

<details>
<summary>Объяснение наборов доступности и зон доступности</summary><br><b>

Набор доступности - это логическая группировка виртуальных машин, которая позволяет Azure понять, как построено ваше приложение, чтобы обеспечить избыточность и доступность. Рекомендуется создавать две или более ВМ в наборе доступности для обеспечения высокой доступности приложения и соответствия требованиям Azure SLA 99,95%.
</b></details>>

<details>
<summary>Что такое Azure Policy? </summary><br><b>
</b></details>>

<details>
<summary>Что такое диспетчер ресурсов Azure? Можете ли вы описать формат шаблонов ARM? </summary><br><b>
</b></details>>

<details>
<summary>Объяснение управляемых дисков Azure</summary><br><b>
</b></details>>

#### Azure - вычисления

<details>
<summary>С какими вычислительными службами Azure вы знакомы? </summary><br><b>

  * Виртуальные машины Azure
  * Azure Batch
  * Azure Service Fabric
  * Контейнерные экземпляры Azure
  * Наборы для масштабирования виртуальных машин Azure
</b></details>>

<details>
<summary>Для чего используется служба "Виртуальные машины Azure"? </summary><br><b>

Виртуальные машины Windows или Linux
</b></details>>

<details>
<summary>Для чего используется служба "Azure Virtual Machine Scale Sets"? </summary><br><b>

Масштабирование виртуальных машин Linux или Windows, используемых в Azure
</b></details>>

<details>
<summary>Для чего используется служба "Azure Functions"? </summary><br><b>

Azure Functions - это служба бессерверных вычислений в Azure.
</b></details>>

<details>
<summary>Для чего используется служба "Azure Container Instances"? </summary><br><b>

Запуск контейнерных приложений (без необходимости предоставления виртуальных машин).
</b></details>>

<details>
<summary>Для чего используется служба "Azure Batch"? </summary><br><b>

Выполнение параллельных и высокопроизводительных вычислительных приложений
</b></details>>

<details>
<summary>Для чего используется служба "Azure Service Fabric"? </summary><br><b>
</b></details>>

<details>
<summary>Для чего используется служба "Azure Kubernetes"? </summary><br><b>
</b></details>>

#### Azure - Сеть

<details>
<summary>С какими сетевыми службами Azure вы знакомы? </summary><br><b>
</b></details>>

<details>
<summary>Что такое регион Azure? </summary><br><b>
</b></details>>

<details>
<summary>Что такое N-уровневая архитектура?</summary><br><b>
</b></details>>

#### Azure Storage

<details>
<summary>С какими службами хранения данных Azure вы знакомы? </summary><br><b>
</b></details>>

<details>
<summary>Какие варианты хранения поддерживает Azure?</summary><br><b>
</b></details>>

#### Безопасность Azure

<details>
<summary>Что такое Центр безопасности Azure? Каковы некоторые из его функций?</summary><br><b>

Это служба мониторинга, которая обеспечивает защиту от угроз всех служб в Azure.
В частности, это:

* Предоставляет рекомендации по безопасности на основе вашего использования
* Контролирует настройки безопасности и непрерывно все службы
* Анализирует и выявляет потенциальные входящие атаки.
* Обнаружение и блокирование вредоносных программ с помощью машинного обучения.
</b></details>>

<details>
<summary>Что такое Azure Active Directory? </summary><br><b>

Azure AD - это облачная служба идентификации. Вы можете использовать ее как отдельную службу или интегрировать с уже существующей службой Active Directory.
</b></details>>

<details>
<summary>Что такое Azure Advanced Threat Protection? </summary><br><b>
</b></details>>

<details>
<summary>Какие компоненты входят в состав Azure ATP?</summary><br><b>
</b></details>>

<details>
<summary>Где хранятся журналы в Azure Monitor?</summary><br><b>
</b></details>>

<details>
<summary>Объяснение Azure Site Recovery</summary><br><b>
</b></details>>

<details>
<summary>Объясните, что делает советник</summary><br><b>
</b></details>>

<details>
<summary>Объяснение пиринга VNet</summary><br><b>
</b></details>>

<details>
<summary>Какие протоколы доступны для настройки датчика здоровья</summary><br><b>
</b></details>>

<details>
<summary>Объяснение Azure Active</summary><br><b>
</b></details>>

<details>
<summary>Что такое подписка? Какие виды подписок существуют? </summary><br><b>
</b></details>>

<details>
<summary>Объясните, что такое служба хранения блобов</summary><br><b>
</b></details>>

## GCP

<details>
<summary>Объяснение архитектуры GCP</summary><br><b>
</b></details>>

<details>
<summary>Каковы основные компоненты и услуги GCP?</summary><br><b>
</b></details>>

<details>
<summary>Какие инструменты управления GCP вам знакомы? </summary><br><b>
</b></details>>

<details>
<summary>Расскажите, что вы знаете о сетевом взаимодействии GCP</summary><br><b>
</b></details>>

<details>
<summary>Объяснение облачных функций</summary><br><b>
</b></details>>

<details>
<summary>Что такое Cloud Datastore? </summary><br><b>
</b></details>>

<details>
<summary>Для чего используются сетевые теги?</summary><br><b>
</b></details>>

<details>
<summary>Что такое журналы потока? Где они включены? </summary><br><b>
</b></details>>

<details>
<summary>Как составить список ведер?</summary><br><b>
</b></details>>

<details>
<summary>Какой ключ метаданных Compute позволяет запускать код при запуске?</summary><br><b>

startap-script
</b></details>>

<details>
<summary>Что делают следующие команды? `gcloud deployment-manager deployments create`</summary><br><b>
</b></details>>

<details>
<summary>Что такое облачный код? </summary><br><b>
Это набор инструментов, помогающих разработчикам писать, запускать и отлаживать приложения на базе GCP kubernetes. Он обеспечивает встроенную поддержку для быстрой итерации, отладки и запуска приложений в средах разработки и производства K8s.
</b></details>>

### Google Kubernetes Engine (GKE)

<details>
<summary>Что такое GKE</summary><br><b>

* Это управляемый сервис kubernetes на GCP для развертывания, управления и масштабирования контейнерных приложений с использованием инфраструктуры Google.
</b></details>>

### Anthos

<details>
<summary>Что такое Anthos</summary><br><b>
Это управляемая платформа приложений для таких организаций, как предприятия, которым требуется быстрая модернизация и определенные уровни
согласованности для своих унаследованных приложений в гибридном или мультиоблачном мире. Из этого объяснения можно извлечь основные идеи;

* Управляемый -> клиенту не нужно беспокоиться об интеграции базового программного обеспечения, он просто включает API.
* платформа приложений -> Она состоит из инструментов с открытым исходным кодом, таких как K8s, Knative, Istio и Tekton
* Предприятия -> обычно это организации со сложными потребностями
* Согласованность -> иметь одни и те же политики, декларативно инициированные для безопасного запуска в любом месте, например, в локальной сети, GCP или других облаках (AWS или Azure).

Забавный факт: Anthos на греческом языке означает "цветок", они растут в земле (earth), но для процветания им нужен дождь из облаков.
</b></details>>

<details>
<summary>Перечислите технические компоненты, из которых состоит Anthos</summary><br><b>

* Управление инфраструктурой - Google Kubernetes Engine (GKE)
* Управление кластером - GKE, Ingress для Anthos
* Управление услугами - Anthos Service Mesh
* Применение политик - Anthos Config Management, Anthos Enterprise Data Protection, Policy Controller.
* Развертывание приложений - инструменты CI/CD, такие как Cloud Build, GitLab.
* Разработка приложений - Облачный код
</b></details>>

<details>
<summary>Что является основной вычислительной средой для Anthos, чтобы легко управлять развертыванием рабочей нагрузки?</summary><br><b>

* Google Kubernetes Engine (GKE)
</b></details>>

<details>
<summary>Как Anthos обрабатывает плоскость управления и узловые компоненты для GKE?</summary><br><b>

На GCP api-сервер kubernetes является единственным компонентом плоскости управления, доступным клиентам, в то время как вычислительный движок управляет
экземпляров в проекте.
</b></details>>

<details>
<summary>Какие варианты балансировки нагрузки доступны? </summary><br><b>

* Балансировка сетевой нагрузки для L4 и балансировка нагрузки HTTP(S) для L7, которые являются управляемыми услугами, не требующими затрат.
  дополнительная конфигурация.
* Ingress для Anthos, который позволяет развернуть балансировщик нагрузки, обслуживающий приложение на нескольких кластерах.
  на GKE
</b></details>>

<details>
<summary>Вы можете развернуть Anthos на AWS? </summary><br><b>

* Да, Anthos на AWS теперь GA. Подробнее читайте [здесь] (https://cloud.google.com/anthos/gke/docs/aws)
</b></details>>

<details>
<summary>Перечислить и объяснить возможности обеспечения безопасности предприятия, предоставляемые Anthos</summary><br><b>

* Безопасность плоскости управления - GCP управляет и обслуживает плоскость управления K8s из коробки. Пользователь может защитить api-сервер с помощью авторизованных сетей мастера и частных кластеров. Они позволяют пользователю отключить доступ к публичному IP-адресу, назначив мастеру частный IP-адрес.
* Безопасность узлов - по умолчанию рабочие нагрузки предоставляются на экземплярах Compute engine, использующих оптимизированную для контейнеров ОС Google. Эта операционная система реализует заблокированный брандмауэр, ограниченные учетные записи пользователей с отключенным root и файловую систему только для чтения. Существует дополнительная возможность включить GKE Sandbox для усиления изоляции в многопользовательских сценариях развертывания.
* Безопасность сети - В рамках созданного кластера VPC Anthos GKE использует мощную программно-определяемую сеть, которая обеспечивает простую связь между модулями. Сетевые политики позволяют блокировать входящие и исходящие соединения в заданном пространстве имен. Фильтрация также может быть реализована для входящего трафика с балансировкой нагрузки для служб, требующих внешнего доступа, путем предоставления белых списков CIDR IP диапазонов.
* Безопасность рабочих нагрузок - рабочие нагрузки запускаются с ограниченными привилегиями, политики безопасности Docker AppArmor по умолчанию применяются ко всем Kubernetes Pods. Идентификация рабочей нагрузки для Anthos GKE соответствует учетным записям служб kubernetes с открытым исходным кодом и разрешениями учетной записи службы GCP.
* Регистрация аудита - администраторы получают возможность сохранять, запрашивать, обрабатывать и оповещать о событиях развернутых сред.
</b></details>>

<details>
<summary>Как рабочие нагрузки, развернутые на локальных кластерах Anthos GKE, могут безопасно подключаться к облачным службам Google? </summary><br><b>

* Виртуальная частная сеть Google Cloud Virtual Private Network (Cloud VPN) - для безопасной работы в сети.
* Google Cloud Key Management Service (Cloud KMS) - для управления ключами
</b></details>>

<details>
<summary>Что такое конфигурация Island Mode в отношении сетевого взаимодействия в Anthos GKE, развернутом в локальной сети?</summary><br><b>

* Это когда стручки могут напрямую общаться друг с другом внутри кластера, но не могут быть доступны извне кластера, образуя "остров" внутри сети, не подключенный к внешней сети.
</b></details>>

<details>
<summary>Объяснение управления конфигурацией Anthos</summary><br><b>

Это основной компонент стека Anthos, который предоставляет операторам платформ, сервисов и систем безопасности единый, унифицированный подход к управлению несколькими кластерами, охватывающий как локальные, так и облачные среды. Он строго следует лучшим практикам K8s, отдавая предпочтение декларативным подходам перед императивными операциями, активно отслеживает состояние кластера и применяет желаемое состояние, определенное в Git. Он включает в себя три следующих ключевых компонента:

1. Импортер, который считывает данные из центрального Git-репозитория
2. Компонент, который синхронизирует сохраненные данные конфигурации в объекты K8s
3. Компонент, отслеживающий дрейф между желаемой и фактической конфигурациями кластера с возможностью согласования в случае необходимости.
</b></details>>

<details>
<summary>Как помогает Anthos Config Management? </summary><br><b>

Он следует общепринятым современным практикам разработки программного обеспечения, что делает изменения конфигурации, управления и политики кластера проверяемыми, восстанавливаемыми и версионируемыми, легко обеспечивая управление ИТ и унифицируя управление ресурсами в организации.
</b></details>>

<details>
<summary>Что такое Anthos Service Mesh? </summary><br><b>

* Это набор инструментов для мониторинга и управления развернутыми сервисами на Anthos всех форм и размеров, работающих в облачных, гибридных или мультиоблачных средах. В нем используются API и основные компоненты Istio, высококонфигурируемой платформы с открытым исходным кодом для объединения сервисов.
</b></details>>

<details>
<summary>Описание двух основных компонентов Anthos Service Mesh</summary><br><b>

1. Плоскость данных - она состоит из набора распределенных прокси-серверов, которые посредничают во всем входящем и исходящем сетевом трафике между отдельными службами, которые конфигурируются с помощью централизованной плоскости управления и открытого API.
2. Плоскость управления - полностью управляемое предложение вне кластеров Anthos GKE для упрощения накладных расходов на управление и обеспечения максимально возможной доступности.
</b></details>>

<details>
<summary>Какие компоненты управляемой плоскости управления Anthos Service Mesh? </summary><br><b>

1. Traffic Director - это полностью управляемая плоскость управления трафиком сервисной сетки GCP, отвечающая за преобразование объектов API Istio в конфигурационную информацию для распределенных прокси, а также за направление входящего и исходящего трафика сервисной сетки.
2. Управляемый ЦС - централизованный центр сертификации, отвечающий за предоставление SSL-сертификатов каждому из распределенных прокси-серверов, аутентификационной информации и распределение секретов.
3. Инструментарий операций - бывший stackdriver, обеспечивает управляемую точку входа для наблюдаемости и телеметрии, в частности, мониторинга, трассировки и регистрации данных, генерируемых каждым из прокси. Это позволяет операторам создавать приборную панель наблюдаемости для визуального контроля своих сервисов и зависимостей сервисов, помогая внедрять передовые методы SRE для мониторинга SLI и создания SLO.
</b></details>>

<details>
<summary>Как помогает Anthos Service Mesh?</summary><br><b>
Интеграция инструментов и технологий, составляющая сервисную сетку Anthos, обеспечивает значительные операционные преимущества для сред Anthos при минимальных дополнительных накладных расходах:

* Единообразная наблюдаемость - плоскость данных сообщает о связи между сервисами обратно в плоскость управления, создавая граф зависимостей сервисов. Проверка трафика прокси-сервером вставляет заголовки для облегчения распределенной трассировки, сбора и предоставления журналов служб вместе с метриками уровня служб (т.е. задержки, ошибки, доступность).
* Операционная гибкость - обеспечивается тонкий контроль для управления потоками межсетевого (север-юг) и внутрисетевого (восток-запад) трафика.
* Безопасность на основе политик - политики могут применяться последовательно в различных протоколах и режимах работы, поскольку служебные коммуникации защищены по умолчанию.
</b></details>>

<details>
<summary>Перечень возможных вариантов использования средств управления движением, которые могут быть реализованы в Anthos Service Mesh</summary><br><b>

* Разделение трафика между различными версиями услуг для канального или A/B тестирования
* Разрыв цепи для предотвращения каскадных отказов
* Внедрение отказов для создания устойчивых и отказоустойчивых развертываний.
* Управление трафиком на основе заголовков HTTP между отдельными службами или версиями
</b></details>>

<details>
<summary>Что такое Cloud Run для Anthos? </summary><br><b>

Он является частью стека Anthos, который привносит в Anthos бессерверный контейнерный опыт, предлагая высокоуровневый платформенный опыт поверх кластеров K8s. Он построен с использованием Knative, оператора с открытым исходным кодом для K8s, который предоставляет возможности бессерверного обслуживания приложений и обработки событий.
</b></details>>

<details>
<summary>Как Cloud Run для Anthos упрощает работу? </summary><br><b>

Команды разработчиков платформ в организациях, которые хотят предложить разработчикам дополнительные инструменты для тестирования, развертывания и запуска приложений, могут использовать Knative для улучшения этого опыта на Anthos как Cloud Run. Ниже приведены некоторые из преимуществ;

* Простая миграция с развертываний K8s - Без Cloud Run инженерам платформы приходится настраивать развертывания, службы и объекты HorizontalPodAutoscalers(HPA) для балансировщика нагрузки и автомасштабирования. Если приложение уже обслуживает трафик, становится трудно изменить конфигурацию или эффективно откатиться назад. При использовании Cloud Run все это управляется таким образом, что манифест сервиса Knative описывает приложение для автомасштабирования и балансировки нагрузки.
* Автомасштабирование - внезапный всплеск трафика может привести к сбою контейнеров приложений в K8s из-за перегрузки, поэтому для обслуживания большого объема трафика выполняется эффективное автоматическое автомасштабирование.
* Сеть - имеет встроенные возможности балансировки нагрузки и политики для разделения трафика между несколькими версиями приложения.
* Релизы и развертывания - поддерживает понятие ревизий Knatibe API, которые описывают новые версии или различные конфигурации вашего приложения и канареечные развертывания путем разделения трафика.
* Мониторинг - наблюдение и запись таких показателей, как задержка, частота ошибок и количество запросов в секунду.
</b></details>>

<details>
<summary>Перечислите и объясните три высокоуровневых примитива автомасштабирования из коробки, предлагаемых Cloud Run для Anthos, которые не существуют в K8s изначально</summary><br><b>

* Быстрое автомасштабирование на основе запросов - автомасштабирование по умолчанию отслеживает метрики запросов, что позволяет Cloud Run для Anthos плавно справляться с резкими изменениями трафика.
* Контроль параллелизма - ограничения, такие как максимальное количество запросов в полете на контейнер, обеспечиваются для того, чтобы контейнер не перегружался и не падал. Для обработки резкого трафика добавляются дополнительные контейнеры, буферизирующие запросы.
* Масштабирование до нуля - если приложение неактивно в течение некоторого времени, Cloud Run масштабирует его до нуля, чтобы уменьшить его след. В качестве альтернативы можно отключить масштабирование до нуля, чтобы предотвратить холодный старт.
</b></details>>

<details>
<summary>Перечень некоторых случаев использования Cloud Run для Anthos</summary><br><b>

Поскольку он не поддерживает приложения с состоянием или липкие сессии, он подходит для запуска приложений без состояния, таких как:

* Прогнозирование моделей машинного обучения, например, контейнеров для обслуживания Tensorflow.
* API-шлюзы, промежуточное ПО API, фронтальные веб-контакты и микросервисы.
* Обработчики событий, ETL
</b></details>>

## OpenStack

<details>
<summary>С какими компонентами/проектами OpenStack вы знакомы? </summary><br><b>
</b></details>>

<details>
<summary>Вы можете сказать мне, за что отвечает каждая из следующих служб/проектов?

  - Нова
  - Нейтрон
  - Золушка
  - Взгляд
  - Keystone</summary><br><b>

  * Nova - Управление виртуальными экземплярами
  * Хранение шлакоблоков
  * Keystone - служба аутентификации в облаке
</b></details>>

<details>
<summary>Идентифицируйте услугу/проект, используемый для каждого из следующих случаев:

  * Копирование или моментальный снимок экземпляров
  * GUI для просмотра и изменения ресурсов
  * Блочное хранилище
  * Управление виртуальными экземплярами
</summary><br><b>

  * Glance - служба изображений. Также используется для копирования или моментального снимка экземпляров
  * Horizon - графический интерфейс для просмотра и изменения ресурсов
  * Хранение шлакоблоков
  * Nova - Управление виртуальными экземплярами
</b></details>>

<details>
<summary>Что такое арендатор/проект?</summary><br><b>
</b></details>>

<details>
<summary>Определяет true или false:

  * OpenStack является бесплатным для использования
  * Служба, отвечающая за работу с сетью, - Glance
  * Целью tenant/project является совместное использование ресурсов между различными проектами и пользователями OpenStack</summary><br><b>.
</b></details>>

<details>
<summary>Подробно описывается, как поднять экземпляр с плавающим IP</summary><br><b>
</b></details>>

<details>
<summary>Вы получаете звонок от клиента со словами: "Я могу пинговать мой экземпляр, но не могу подключиться к нему (ssh)". В чем может быть проблема? </summary><br><b>
</b></details>>

<details>
<summary>Какие типы сетей поддерживает OpenStack?</summary><br><b>
</b></details>>

<details>
<summary>Как отладить проблемы с хранилищем OpenStack? (инструменты, журналы, ...)</summary><br><b>
</b></details>>

<details>
<summary>Как отладить проблемы с вычислениями OpenStack? (инструменты, журналы, ...)</summary><br><b>
</b></details>>

#### OpenStack Deployment & TripleO

<details>
<summary>Вы развертывали OpenStack в прошлом? Если да, то можете описать, как вы это делали? </summary><br><b>
</b></details>>

<details>
<summary>Вы знакомы с TripleO? Чем он отличается от Devstack или Packstack? </summary><br><b>

Вы можете прочитать о TripleO прямо [здесь] (https://docs.openstack.org/tripleo-docs/latest).
</b></details>>

#### OpenStack Compute

<details>
<summary>Можете ли вы подробно описать Nova? </summary><br><b>

  * Используется для предоставления и управления виртуальными экземплярами
  * Поддерживается многопользовательская аренда на разных уровнях - ведение журналов, контроль конечных пользователей, аудит и т.д.
  * Высокая масштабируемость
  * Аутентификация может быть выполнена с помощью внутренней системы или LDAP
  * Поддержка нескольких типов блочного хранилища
  * Пытается быть агностиком аппаратного и гипервизорного обеспечения
</b></details>>

<details>
<summary>Что вы знаете об архитектуре и компонентах Nova? </summary><br><b>

  * nova-api - сервер, обслуживающий метаданные и вычислительные API.
  * различные компоненты Nova взаимодействуют с помощью очереди (обычно Rabbitmq) и базы данных
  * запрос на создание экземпляра проверяется nova-scheduler, который определяет, где будет создан и запущен экземпляр
  * nova-compute - компонент, отвечающий за взаимодействие с гипервизором для создания экземпляра и управления его жизненным циклом.
</b></details>>

#### OpenStack Networking (Neutron)

<details>
<summary>Подробное объяснение Neutron</summary><br><b>

  * Один из основных компонентов OpenStack и самостоятельный проект
  * Neutron сосредоточился на предоставлении сетей как услуги
  * С помощью Neutron пользователи могут создавать сети в облаке, настраивать и управлять различными сетевыми службами.
  * Нейтрон взаимодействует с:
      * Keystone - авторизация вызовов API
      * Nova - nova взаимодействует с neutron для подключения сетевых карт к сети
      * Horizon - поддерживает сетевые сущности в приборной панели, а также предоставляет представление топологии, включающее детали сети
</b></details>>

<details>
<summary>Объясните каждый из следующих компонентов:

  - neutron-dhcp-agent
  - neutron-l3-agent
  - нейтронный измеритель-агент
  - нейтрон-*-агент
  - neutron-server</summary><br><b>


  * neutron-l3-agent - L3/NAT форвардинг (обеспечивает доступ к внешней сети для виртуальных машин, например)
  * neutron-dhcp-agent - службы DHCP
  * neutron-metering-agent - учет трафика L3
  * neutron-*-agtent - управляет локальной конфигурацией vSwitch на каждом компьютере (на основе выбранного плагина).
  * neutron-server - раскрывает сетевой API и передает запросы другим плагинам, если это необходимо
</b></details>>

<details>
<summary>Объясните эти типы сетей:

  - Сеть управления
  - Гостевая сеть
  - Сеть API
  - Внешняя сеть</summary><br><b>

  * Сеть управления - используется для внутренней связи между компонентами OpenStack. Любой IP-адрес в этой сети доступен только в пределах datacetner
  * Гостевая сеть - используется для связи между экземплярами/VM
  * API Network - используется для связи API сервисов. Любой IP-адрес в этой сети является общедоступным
  * Внешняя сеть - используется для публичного общения. Любой IP-адрес в этой сети доступен любому пользователю Интернета
</b></details>>

<details>
<summary>В каком порядке вы должны удалить следующие сущности:

  * Сеть
  * Порт
  * Маршрутизатор
  * Подсеть</summary><br><b>

  - порт
  - Подсеть
  - Маршрутизатор
  - Сеть

На это есть много причин. Например, вы не можете удалить маршрутизатор, если ему назначены активные порты.
</b></details>>

<details>
<summary>Что такое сеть поставщиков? </summary><br><b>
</b></details>>

<details>
<summary>Какие компоненты и службы существуют для L2 и L3?</summary><br><b>
</b></details>>

<details>
<summary>Что такое плагин ML2? Объясните его архитектуру</summary><br><b>
</b></details>>

<details>
<summary>Что такое агент L2? Как он работает и за что отвечает? </summary><br><b>
</b></details>>

<details>
<summary>Что такое агент L3? Как он работает и за что отвечает? </summary><br><b>
</b></details>>

<details>
<summary>Объясните, за что отвечает агент метаданных</summary><br><b>
</b></details>>

<details>
<summary>Какие сетевые сущности поддерживает Neutron?</summary><br><b>
</b></details>>

<details>
<summary>Как отладить сетевые проблемы OpenStack? (инструменты, журналы, ...)</summary><br><b>
</b></details>>

#### OpenStack - Glance

<details>
<summary>Подробное объяснение Glance</summary><br><b>

  * Glance - служба изображений OpenStack.
  * Он обрабатывает запросы, связанные с дисками и образами экземпляров
  * Glance также используется для создания моментальных снимков для быстрого резервного копирования экземпляров
  * Пользователи могут использовать Glance для создания новых изображений или загрузки существующих.
</b></details>>

<details>
<summary>Описание архитектуры Glance</summary><br><b>

  * glance-api - отвечает за обработку вызовов API изображений, таких как получение и хранение. Он состоит из двух API: 1. registry-api - отвечает за внутренние запросы 2. user API - может быть доступен публично
  * glance-registry - отвечает за обработку запросов метаданных изображения (например, размер, тип и т.д.). Этот компонент является приватным, что означает, что он недоступен публично
  * служба определения метаданных - API для пользовательских метаданных
  * база данных - для хранения метаданных изображений
  * хранилище изображений - для хранения изображений. Это может быть файловая система, хранилище объектов swift, HTTP и т.д.
</b></details>>

#### OpenStack - Swift

<details>
<summary>Подробное объяснение Swift</summary><br><b>

  * Swift - это служба Object Store, которая представляет собой высокодоступное, распределенное и согласованное хранилище, предназначенное для хранения большого количества данных.
  * Swift распределяет данные по нескольким серверам, записывая их на несколько дисков
  * Можно добавлять дополнительные серверы для масштабирования кластера. При этом сохраняется целостность информации и репликации данных.
</b></details>>

<details>
<summary>Могут ли пользователи по умолчанию хранить объект размером 100 ГБ?</summary><br><b>

По умолчанию нет. Object Storage API ограничивает максимальное значение до 5 ГБ на объект, но его можно настроить.
</b></details>>

<details>
<summary>Объясните следующее в отношении Swift:

  * Контейнер
  * Счет
  * Объект
</summary><br><b>

  - Контейнер - Определяет пространство имен для объектов.
  - Account - Определяет пространство имен для контейнеров
  - Объект - содержимое данных (например, изображение, документ, ...)
</b></details>>

<details>
<summary>Истина или ложь? В одном контейнере могут быть два объекта с одинаковым именем, но не в двух разных контейнерах</summary><br><b>

Ложь. Два объекта могут иметь одинаковое имя, если они находятся в разных контейнерах.
</b></details>>

#### OpenStack - Cinder

<details>
<summary>Подробное объяснение Cinder</summary><br><b>

  * Cinder - служба хранения блоков OpenStack.
  * Он в основном предоставляет ресурсы для хранения, которые они могут использовать с другими сервисами, такими как Nova
  * Одной из наиболее используемых реализаций хранения, поддерживаемых Cinder, является LVM.
  * С точки зрения пользователя это прозрачно, что означает, что пользователь не знает, где за кулисами находится хранилище или какой тип хранилища используется.
</b></details>>

<details>
<summary>Описание компонентов Cinder</summary><br><b>

  * cinder-api - принимает запросы API
  * cinder-volume - управляет подключенными блочными устройствами
  * cinder-scheduler - отвечает за хранение томов.
</b></details>>


#### OpenStack - Keystone

<details>
<summary>Можете ли вы описать следующие понятия в отношении Keystone?

  - Роль
  - Арендатор/проект
  - Сервис
  - Конечная точка
  - Жетон
</summary><br><b>

  - Роль - список прав и привилегий, определяющих, что может выполнять пользователь или проект.
  - Арендатор/проект - Логическое представление группы ресурсов, изолированных от других групп ресурсов. Это может быть учетная запись, организация, ...
  - Сервис - конечная точка, которую пользователь может использовать для доступа к различным ресурсам
  - Конечная точка - сетевой адрес, который может быть использован для доступа к определенной службе OpenStack
  - Токен - Используется для доступа к ресурсам, описывая, к каким ресурсам можно получить доступ с помощью области видимости
</b></details>

<details>
<summary>Каковы свойства услуги? Другими словами, как идентифицируется услуга? </summary><br><b>

Использование:
  - имя
  - идентификационный номер
  - Тип
  - Описание
</b></details>

<details>
<summary>Объясните следующее:
  - ПубличныйURL
  - ВнутреннийURL
  - AdminURL</summary><br><b>

  - PublicURL - Публично доступный через публичный интернет
  - ВнутреннийURL - Используется для связи между службами
  - AdminURL - Используется для административного управления
</b></details>

<details>
<summary>Что такое каталог услуг? </summary><br><b>

Список служб и их конечных точек
</b></details>

#### OpenStack Advanced - Services

<details>
<summary>Опишите каждую из следующих служб

  * Свифт
  * Сахара
  * Ирония
  * Trove
  * Aodh
  * Потолок
</summary><br><b>

  * Swift - высокодоступное, распределенное, в конечном итоге согласованное хранилище объектов/баз данных.
  * Sahara - Управление кластерами Hadoop
  * Ironic - Bare Metal Provisioning
  * Trove - база данных как сервис, работающий на OpenStack
  * Aodh - Служба сигнализации
  * Ceilometer - отслеживание и мониторинг использования
</b></details>

<details>
<summary>Идентифицируйте услугу/проект, используемый для каждого из следующих случаев:

  * База данных как сервис, работающий на OpenStack
  * Bare Metal Provisioning
  * Отслеживать и контролировать использование
  * Служба сигнализации
  * Управление кластерами Hadoop
  * высокодоступное, распределенное, в конечном итоге согласованное хранилище объектов/баз данных
</summary><br><b>

  * База данных как сервис, работающий на OpenStack - Trove
  * Bare Metal Provisioning - Ironic
  * Отслеживание и мониторинг использования - Ceilometer
  * Служба сигнализации - Aodh
  * Управление кластерами Hadoop
  * Управление кластерами Hadoop - Сахара
  * высокодоступное, распределенное, в конечном итоге согласованное хранилище объектов/баз данных - Swift
</b></details>

#### OpenStack Advanced - Keystone

<details>
<summary>Можете ли вы подробно описать услугу Keystone? </summary><br><b>

  * Вы не можете развернуть OpenStack без Keystone.
  * Предоставляет услуги идентификации, политики и маркеров.
    * Аутентификация предоставляется как для пользователей, так и для служб
    * Поддерживается авторизация на основе токенов и на основе пользователя.
  * Существует политика, определенная на основе RBAC, хранящаяся в файле JSON, и каждая строка в этом файле определяет уровень доступа, который необходимо применить.
</b></details>

<details>
<summary>Описание архитектуры Keystone</summary><br><b>

  * Существует API сервиса и API администратора, через которые Keystone получает запросы.
  * Keystone имеет четыре бэкенда:
    * Token Backend - временные токены для пользователей и сервисов
    * Бэкэнд политики - управление правилами и авторизация
    * Бэкэнд идентификации - пользователи и группы (либо отдельная БД, LDAP, ...)
    * Бэкэнд каталога - конечные точки
  * Она имеет подключаемую среду, в которую можно интегрироваться:
    * LDAP
    * KVS (Key Value Store)
    * SQL
    * PAM
    * Memcached
</b></details>

<details>
<summary>Описание процесса аутентификации Keystone</summary><br><b>

  * Keystone получает звонок/запрос и проверяет, исходит ли он от авторизованного пользователя, используя имя пользователя, пароль и authURL.
  * После подтверждения Keystone предоставляет токен.
  * Токен содержит список проектов пользователя, поэтому нет необходимости каждый раз проходить аутентификацию, вместо этого можно отправить токен.
</b></details>

#### OpenStack Advanced - Compute (Nova)

<details>
<summary>Что делает каждый из следующих элементов?

  * nova-api
  * nova-compuate
  * nova-conductor
  * nova-cert
  * nova-consoleauth
  * nova-scheduler
</summary><br><b>

  * nova-api - отвечает за управление запросами/вызовами.
  * nova-compute - отвечает за управление жизненным циклом экземпляров
  * nova-conductor - Посредник между nova-compute и базой данных, так что nova-compute не обращается к ней напрямую.
</b></details>

<details>
<summary>С какими типами прокси-серверов Nova вы знакомы? </summary><br><b>

  * Nova-novncproxy - доступ через VNC-соединения
  * Nova-spicehtml5proxy - доступ через SPICE
  * Nova-xvpvncproxy - Доступ через VNC-соединение
</b></details>

#### OpenStack Advanced - Networking (Neutron)

<details>
<summary>Объяснение динамической маршрутизации BGP</summary><br><b>
</b></details>

<details>
<summary>Какова роль сетевых пространств имен в OpenStack? </summary><br><b>
</b></details>

#### OpenStack Advanced - Horizon

<details>
<summary>Можете ли вы подробно описать Горизонт? </summary><br><b>

  * Проект на основе Django, сфокусированный на предоставлении приборной панели OpenStack и возможности создания дополнительных настраиваемых приборных панелей.
  * Вы можете использовать его для доступа к различным ресурсам сервисов OpenStack - экземплярам, образам, сетям, ...
    * Получив доступ к приборной панели, пользователи могут использовать ее для перечисления, создания, удаления и изменения различных ресурсов.
  * Он также хорошо настраивается, и вы можете изменять или дополнять его в зависимости от ваших потребностей.
</b></details>

<details>
<summary>Что вы можете сказать об архитектуре Horizon? </summary><br><b>

  * API имеет обратную совместимость
  * Существует три типа приборных панелей: пользовательские, системные и панели настроек.
  * Обеспечивает поддержку всех основных проектов OpenStack, таких как Neutron, Nova и др. (из коробки, без необходимости установки дополнительных пакетов или плагинов)
  * Любой желающий может расширять приборные панели и добавлять новые компоненты
  * Horizon предоставляет шаблоны и основные классы, на основе которых можно создать собственную приборную панель.
</b></details>

## Puppet

<details>
<summary>Что такое Puppet? Как он работает? </summary><br><b>
</b></details>

<details>
<summary>Объяснение архитектуры Puppet</summary><br><b>
</b></details>

<details>
<summary>Можете ли вы сравнить Puppet с другими инструментами управления конфигурацией? Почему вы решили использовать Puppet? </summary><br><b>
</b></details>

<details>
<summary>Объясните следующее:

  * Модуль
  * Манифест
  * Узел</summary><br><b>
</b></details>

<details>
<summary>Объяснение фактора</summary><br><b>
</b></details>

<details>
<summary>Что такое MCollective? </summary><br><b>
</b></details>

<details>
<summary>У вас есть опыт написания модулей? Какой модуль вы создали и для чего? </summary><br><b>
</b></details>

<details>
<summary>Объясните, что такое Hiera</summary><br><b>
</b></details>

## Elastic

<details>
<summary>Что такое Elastic Stack? </summary><br><b>

Эластичный стек состоит из:

  * Elasticsearch
  * Kibana
  * Logstash
  * Битлз
  * Elastic Hadoop
  * Сервер APM

Elasticserach, Logstash и Kibana также известны как стек ELK.
</b></details>

<details>
<summary>Объяснение того, что такое Elasticsearch</summary><br><b>

Из официального [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/documents-indices.html):

"Elasticsearch - это распределенное хранилище документов. Вместо того чтобы хранить информацию в виде строк данных в столбцах, Elasticsearch хранит сложные структуры данных, которые были сериализованы в виде документов JSON".
</b></details>

<details>
<summary>Что такое Logstash? </summary><br><b>
	
Из [блога](https://logit.io/blog/post/the-top-50-elk-stack-and-elasticsearch-interview-questions):

"Logstash - это мощный, гибкий конвейер, который собирает, обогащает и транспортирует данные. Он работает как инструмент извлечения, преобразования и загрузки (ETL) для сбора сообщений журнала."
</b></details>

<details>
<summary>Объясните, что такое биты</summary><br><b>

Beats - это легковесные отправители данных. Эти отправители данных устанавливаются на клиенте, где находятся данные.
Примеры ударов: Filebeat, Metricbeat, Auditbeat. Их гораздо больше.<br>
</b></details>

<details>
<summary>Что такое Kibana?</summary><br><b>

Из официальных документов:

"Kibana" - это платформа аналитики и визуализации с открытым исходным кодом, разработанная для работы с Elasticsearch. Вы используете Kibana для поиска, просмотра и взаимодействия с данными, хранящимися в индексах Elasticsearch. Вы можете легко выполнять расширенный анализ данных и визуализировать их в виде различных графиков, таблиц и карт."
</b></details>

<details>
<summary>Описание того, что происходит с момента регистрации приложением некоторой информации до ее отображения пользователю на приборной панели при использовании стека Elastic</summary><br><b>

Процесс может варьироваться в зависимости от выбранной архитектуры и обработки, которую вы хотите применить к журналам. Один из возможных рабочих процессов таков:

1. Данные, регистрируемые приложением, собираются filebeat и отправляются в logstash
2. Logstash обрабатывает журнал на основе заданных фильтров. После этого результат отправляется в Elasticsearch.
2. Elasticsearch сохраняет полученный документ, и документ индексируется для быстрого доступа к нему в будущем
4. Пользователь создает визуализации в Kibana, которые основаны на проиндексированных данных
5. Пользователь создает приборную панель, которая состоит из визуализации, созданной на предыдущем этапе
</b></details>

##### Elasticsearch

<details>
<summary>Что такое узел данных? </summary><br><b>

Это место, где хранятся данные, а также где происходит их различная обработка (например, при поиске данных).
</b></details>

<details>
<summary>Что такое главный узел? </summary><br><b>

Ответственность главного узла:
  * Отслеживать состояние всех узлов в кластере
  * Убедитесь, что реплики работают и данные доступны с каждого узла данных.
  * Отсутствие горячих узлов (нет узла данных, который работает намного интенсивнее, чем другие узлы)

Хотя может быть несколько главных узлов, в действительности только один из них является избранным главным узлом.
</b></details>

<details>
<summary>Что такое входящий узел? </summary><br><b>

Узел, который отвечает за разбор данных. Если вы не используете logstash, то этот узел может получать данные от битов и разбирать их, аналогично тому, как они разбираются в Logstash.
</b></details>

<details>
<summary>Что такое координационный узел?</summary><br><b>

Координирующий узел, отвечающий за маршрутизацию запросов из и внутрь кластера (узлы данных).
</b></details>

<details>
<summary>Как хранятся данные в elasticsearch?</summary><br><b>

* Данные хранятся в индексе
* Индекс распределяется по кластеру с помощью осколков.
</b></details>

<details>
<summary>Что такое индекс? </summary><br><b>

Индекс в Elastic в большинстве случаев сравнивается с целой базой данных из мира SQL/NoSQL.<br>
Вы можете выбрать один индекс для хранения всех данных вашего приложения или несколько индексов, где каждый индекс хранит различные типы данных вашего приложения (например, индекс для каждого сервиса, запущенного вашим приложением).

Официальная документация также предлагает отличное объяснение (в целом, это действительно хорошая документация, которая должна быть у каждого проекта):

"Индекс можно представить как оптимизированную коллекцию документов, а каждый документ - как коллекцию полей, которые являются парами ключ-значение, содержащими ваши данные".
</b></details>

<details>
<summary>Объяснение Осколков</summary><br><b>

Индекс делится на шарды, и документы хэшируются на определенный шард. Каждый шард может находиться на разных узлах кластера, и каждый из шардов является самостоятельным индексом.<br>
Это позволяет Elasticsearch масштабироваться до целого кластера серверов.
</b></details>

<details>
<summary>Что такое инвертированный индекс?</summary><br><b>

Из официальных документов:

"Инвертированный индекс перечисляет каждое уникальное слово, встречающееся в любом документе, и идентифицирует все документы, в которых встречается это слово".
</b></details>

<details>
<summary>Что такое документ? </summary><br><b>

Продолжая сравнение с SQL/NoSQL, документ в Elastic - это строка в таблице в случае SQL или документ в коллекции в случае NoSQL.
Как и в NoSQL, документ - это объект JSON, который хранит данные о единице в вашем приложении. Что это за единица, зависит от вашего приложения. Если ваше приложение связано с книгами, то каждый документ описывает книгу. Если ваше приложение связано с рубашками, то каждый документ - это рубашка.
</b></details>

<details>
<summary>Вы проверяете состояние кластера elasticsearch, и оно красное. Что это значит? Что может привести к тому, что состояние будет желтым, а не зеленым? </summary><br><b>

Красный цвет означает, что некоторые данные недоступны.
Желтый цвет может быть вызван работой одноузлового кластера вместо многоузлового.
</b></details>

<details>
<summary>Правда или ложь? Elasticsearch индексирует все данные в каждом поле, и каждое индексированное поле имеет одинаковую структуру данных для унификации и возможности быстрого запроса</summary><br><b>.

Ложь.
Из официальных документов:

"Каждое индексированное поле имеет специальную оптимизированную структуру данных. Например, текстовые поля хранятся в инвертированных индексах, а числовые и гео-поля - в BKD-деревьях."
</b></details>

<details>
<summary>Какие зарезервированные поля имеет документ?</summary><br><b>

  * _index
  * _id
  * _type
</b></details>

<details>
<summary>Объяснить отображение</summary><br><b>
</b></details>

<details>
<summary>Каковы преимущества определения собственного отображения? (или: когда вы будете использовать собственное отображение?)</summary><br><b>

* Вы можете оптимизировать поля для частичного соответствия
* Вы можете определить пользовательские форматы известных полей (например, дата).
* Вы можете выполнять анализ с учетом специфики языка
</b></details>

<details>
<summary>Объяснение реплик</summary><br><b>

В сетевой/облачной среде, где сбои могут произойти в любой момент, очень полезно и настоятельно рекомендуется иметь механизм обхода отказа на случай, если шард/узел по какой-либо причине перейдет в автономный режим или исчезнет.
Для этого Elasticsearch позволяет создавать одну или несколько копий шардов вашего индекса в так называемых шардах-репликах, или репликах.
</b></details>

<details>
<summary>Вы можете объяснить, что такое частота термина и частота документа? </summary><br><b>

Частота термина - это частота появления термина в данном документе, а частота документа - частота появления термина во всех документах. Они оба используются для определения релевантности термина путем вычисления частоты термина / частоты документа.
</b></details>

<details>
<summary>Вы проверяете "Текущую фазу" в разделе "Управление жизненным циклом индекса" и видите, что она установлена на "горячую". Что это значит? </summary><br><b>

"В индекс ведется активная запись".
Подробнее о фазах [здесь](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/ilm-policy-definition.html)
</b></details>

<details>
<summary>Что делает эта команда? <code>curl -X PUT "localhost:9200/customer/_doc/1?pretty" -H 'Content-Type: application/json' -d'{"name": "John Doe" }'</code></summary><br><b>

Он создает индекс клиента, если он не существует, и добавляет новый документ с именем поля, которое установлено как "John Dow". Также, если это первый документ, он получит идентификатор 1.
</b></details>

<details>
<summary>Что произойдет, если выполнить предыдущую команду дважды? А если выполнить ее 100 раз? </code></summary><br><b>

1. Если значение имени было другим, то оно обновляет "имя" до нового значения
2. В любом случае, это увеличивает поле версии на одну единицу
</b></details>

<details>
<summary>Что такое Bulk API? Для чего вы его используете? </code></summary><br><b>

Bulk API используется, когда вам нужно проиндексировать множество документов. Для большого количества документов его использование будет значительно быстрее, чем использование отдельных запросов, так как при этом происходит меньше сетевых обходов.
</b></details>

##### Query DSL

<details>
<summary>Объяснение синтаксиса запросов Elasticsearch (булевы, поля, диапазоны)</summary><br><b>
</b></details>

<details>
<summary>Объясните, что такое Relevance Score</summary><br><b>
</b></details>

<details>
<summary>Объяснение контекста запроса и контекста фильтра</summary><br><b>

Из официальных документов:

"В контексте запроса пункт запроса отвечает на вопрос "Насколько хорошо этот документ соответствует этому пункту запроса? " Помимо решения о том, соответствует ли документ или нет, пункт запроса также рассчитывает оценку релевантности в метаполе _score."

"В контексте фильтра пункт запроса отвечает на вопрос "Соответствует ли этот документ данному пункту запроса? " Ответом является простое "Да" или "Нет" - баллы не вычисляются. Контекст фильтра в основном используется для фильтрации структурированных данных".
</b></details>

<details>
<summary>Опишите, как архитектура производственной среды с большим объемом данных будет отличаться от архитектуры среды малого масштаба</summary><br><b>

Есть несколько возможных ответов на этот вопрос. Один из них следующий:

Мелкомасштабная архитектура elastic будет состоять из стека elastic в его нынешнем виде. Это означает, что у нас будут beats, logstash, elastcsearch и kibana.<br>.
Производственная среда с большими объемами данных может включать в себя какой-либо компонент буферизации (например, Reddis или RabbitMQ), а также компонент безопасности, такой как Nginx.
</b></details>

##### Logstash

<details>
<summary>Что такое плагины Logstash? Какие существуют типы плагинов? </summary><br><b>

  * Входные плагины - как собирать данные из различных источников
  * Плагины фильтров - обработка данных
  * Плагины вывода - вывод данных на различные выходы/сервисы/платформы.
</b></details>

<details>
<summary>Что такое grok? </summary><br><b>

Плагин logstash, который изменяет информацию в одном формате и погружает ее в другой.
</b></details>

<details>
<summary>Как работает grok?</summary><br><b>
</b></details>

<details>
<summary>Какие модели грока вам знакомы? </summary><br><b>
</b></details>

<details>
<summary>Что такое `_grokparsefailure?`</summary><br><b>
</b></details>

<details>
<summary>Как проверить или отладить паттерны grok? </summary><br><b>
</b></details>

<details>
<summary>Что такое кодеки Logstash? Какие кодеки существуют? </summary><br><b>
</b></details>

##### Kibana

<details>
<summary>Что вы можете найти в разделе "Discover" в Kibana? </summary><br><b>

Необработанные данные в том виде, в котором они хранятся в индексе. Вы можете искать и фильтровать их.
</b></details>

<details>
<summary>Вы видите в Kibana, после нажатия на Discover, "561 hits". Что это значит? </summary><br><b>

Общее количество документов, соответствующих результатам поиска. Если запрос не используется, то просто общее количество документов.
</b></details>

<details>
<summary>Что вы можете найти в разделе "Визуализация"? </summary><br><b>

"Visualize" - это место, где вы можете создавать визуальные представления для ваших данных (круговые диаграммы, графики, ...).
</b></details>

<details>
<summary>Какие типы визуализации поддерживаются/включены в Kibana?</summary><br><b>
</b></details>

<details>
<summary>Какой тип визуализации вы бы использовали для статистических выбросов</summary><br><b>
</b></details>

<details>
<summary>Подробно опишите, как создать приборную панель в Kibana</summary><br><b>
</b></details>

#### Filebeat

<details>
<summary>Что такое Filebeat? </summary><br><b>
</b></details>

<details>
<summary>Если вы используете ELK, обязательно ли использовать filebeat? В каких сценариях полезно использовать filebeat? </summary><br><b>
</b></details>

<details>
<summary>Что такое комбайн?</summary><br><b>

Читать [здесь] (https://www.elastic.co/guide/en/beats/filebeat/current/how-filebeat-works.html#harvester)
</b></details>

<details>
<summary>Истина или ложь? Один комбайн собирает несколько файлов, в соответствии с ограничениями, установленными в файле filebeat.yml</summary><br><b>

Ложь. Один комбайн собирает один файл.
</b></details>

<details>
<summary>Что такое модули filebeat? </summary><br><b>
</b></details>

#### Эластичный стек

<details>
<summary>Как защитить Elastic Stack? </summary><br><b>

Вы можете генерировать сертификаты с помощью предоставленных эластичных утилит и изменить конфигурацию, чтобы включить безопасность с помощью модели сертификатов.
</b></details>

## Распределенный

<details>
<summary>Объяснение распределенных вычислений (или распределенной системы)</summary><br><b>

По словам Мартина Клеппманна:

"Множество процессов, запущенных на многих машинах... передача сообщений осуществляется только по ненадежной сети с переменными задержками, и система может страдать от частичных сбоев, ненадежных часов и пауз в процессах".

Другое определение: "Системы, которые физически разделены, но логически связаны".
</b></details>

<details>
<summary>Что может привести к отказу системы?</summary><br><b>

* Сеть
* CPU
* Память
* Диск
</b></details>

<details>
<summary>Знаете ли вы, что такое "теорема CAP"? (она же теорема Брюэра)</summary><br><b>

Согласно теореме CAP, невозможно, чтобы распределенное хранилище данных одновременно предоставляло более двух из следующих возможностей:

* Доступность: Каждый запрос получает ответ (это не обязательно должны быть самые последние данные)
* Последовательность: Каждый запрос получает ответ с последними/самыми свежими данными
* Толерантность к разделам: Даже если часть данных будет потеряна или удалена, система продолжит работу
</b></details>

<details>
<summary>Какие проблемы со следующим дизайном? Как ее улучшить? <br>
<img src="images/distributed/distributed_design_standby.png" width="500x;" height="350px;"/>
</summary><br><b>
1. Переход может занять время. Другими словами, заметный простой.
2. Резервный сервер является пустой тратой ресурсов - если первый сервер приложений работает, то резервный ничего не делает
</b></details>

<details>
<summary>Какие проблемы со следующим дизайном? Как ее улучшить? <br>
<img src="images/distributed/distributed_design_lb.png" width="700x;" height="350px;"/>
</summary><br><b>
Вопросы:
Если балансировщик нагрузки умирает, мы теряем возможность взаимодействия с приложением.

Пути улучшения:
* Добавьте еще один балансировщик нагрузки
* Используйте запись DNS A для обоих балансировщиков нагрузки
* Используйте очередь сообщений
</b></details>

<details>
<summary>Что такое архитектура "Shared-Nothing"? </summary><br><b>

Это архитектура, в которой данные и извлекаются из единственного, не разделяемого источника, обычно подключенного исключительно к одному узлу, в отличие от архитектур, в которых запрос может попасть на один из многих узлов, а данные будут извлечены из одного разделяемого места (хранилище, память, ...).
</b></details>

<details>
<summary>Объяснение паттерна Sidecar (или прокси sidecar)</summary><br><b>
</b></details>

## Misc

|Name|Topic|Objective & Instructions|Solution|Comments|
|--------|--------|------|----|----|
| Highly Available "Hello World" | [Exercise](exercises/devops/ha_hello_world.md) | [Solution](exercises/devops/solutions/ha_hello_world.md)

<details>
<summary>Что происходит, когда вы набираете URL в адресной строке браузера?</summary><br><b>

1. Браузер ищет запись IP-адреса доменного имени в DNS в следующем порядке:
  * Кэш браузера
  * Кэш-память операционной системы
  * DNS-сервер, настроенный в системе пользователя (может быть DNS провайдера, публичный DNS, ...)
2. Если не удалось найти запись DNS локально, запускается полное разрешение DNS.
3. Он подключается к серверу с помощью протокола TCP
4. Браузер отправляет HTTP-запрос на сервер.
5. Сервер отправляет ответ HTTP обратно браузеру
6. Браузер отображает ответ (например, HTML)
7. Затем браузер по мере необходимости отправляет последующие запросы на сервер, чтобы получить встроенные ссылки, javascript, изображения в HTML, после чего повторяются шаги с 3 по 5.

TODO: добавьте больше деталей!
</b></details>

#### API

<details>
<summary>Объясните, что такое API</summary><br><b>

Мне нравится это определение из [blog.christianposta.com](https://blog.christianposta.com/microservices/api-gateways-are-going-through-an-identity-crisis):

"Явно и целенаправленно определенный интерфейс, предназначенный для вызова по сети, который позволяет разработчикам программного обеспечения получить программный доступ к данным и функциональности в организации контролируемым и удобным способом".
</b></details>

<details>
<summary>Что такое спецификация API? </summary><br><b>

Из [swagger.io](https://swagger.io/resources/articles/difference-between-api-documentation-specification):

"Спецификация API обеспечивает широкое понимание того, как ведет себя API и как API связан с другими API. Она объясняет, как функционирует API и каких результатов следует ожидать при использовании API".
</b></details>

<details>
<summary>Правда или ложь? Определение API - это то же самое, что и спецификация API</summary><br><b>

False. Из [swagger.io](https://swagger.io/resources/articles/difference-between-api-documentation-specification):

"Определение API похоже на спецификацию API в том, что оно дает понимание того, как устроен API и как API функционирует. Но определение API нацелено на машинное, а не человеческое потребление API".
</b></details>

<details>
<summary>Что такое полезная нагрузка в API? </summary><br><b>
</b></details>

<details>
<summary>Что такое автоматизация? Как она связана или отличается от оркестровки? </summary><br><b>

Автоматизация - это акт автоматизации задач для уменьшения вмешательства или взаимодействия человека в отношении IT-технологий и систем.<br>
В то время как автоматизация сосредоточена на уровне задач, оркестровка - это процесс автоматизации процессов и/или рабочих потоков, состоящих из множества задач, которые обычно выполняются в нескольких системах.
</b></details>

<details>
<summary>Расскажите мне об интересных ошибках, которые вы нашли, а также исправили</summary><br><b>
</b></details>

<details>
<summary>Что такое отладчик и как он работает?</summary><br><b>
</b></details>

<details>
<summary>Какие службы могут быть у приложения?</summary><br><b>

  * Авторизация
  * Ведение журнала
  * Аутентификация
  * Заказ
  * Front-end
  * Back-end
  ...
</b></details>

<details>
<summary>Что такое метаданные?</summary><br><b>

Данные о данных. В основном, они описывают тип информации, которую содержат данные, лежащие в основе данных.
</b></details>

<details>
<summary>Вы можете использовать один из следующих форматов: JSON, YAML, XML. Какой из них вы бы использовали? Почему? </summary><br><b>

Я не могу ответить на этот вопрос за вас :)
</b></details>

<details>
<summary>Что такое KPI?</summary><br><b>
</b></details>

<details>
<summary>Что такое OKR? </summary><br><b>
</b></details>

<details>
<summary>Что такое DSL (Domain Specific Language)? </summary><br><b>

Доменно-специфические языки (DSL) используются для создания специализированного языка, который представляет домен таким образом, что эксперты домена могут легко его интерпретировать.
</b></details>

<details>
<summary>В чем разница между KPI и OKR? </summary><br><b>
</b></details>

#### YAML

<details>
<summary>Что такое YAML?</summary><br><b>

Язык сериализации данных, используемый сегодня многими технологиями, такими как Kubernetes, Ansible и др.
</b></details>

<details>
<summary>Истина или ложь? Любой правильный JSON файл также является правильным YAML файлом</summary><br><b>

Верно. Потому что YAML является супермножеством JSON.
</b></details>

<details>
<summary>Каков формат следующих данных?

```
{
    применения: [
        {
            имя: "my_app",
            язык: "python",
            версия: 20.17
        }
    ]
}
```
</summary><br><b>
JSON
</b></details>

<details>
<summary>Каков формат следующих данных?

```
применения:
  - приложение: "my_app"
    язык: "python"
    версия: 20.17
```
</summary><br><b>
YAML
</b></details>

<details>
<summary>Как написать многострочную строку с помощью YAML? Для каких случаев это полезно? </summary><br><b>

```
someMultiLineString: |
  смотри, мама
  Я могу написать многострочную строку
  Я люблю YAML
```

Это хорошо подходит для таких случаев, как написание сценария оболочки, где каждая строка сценария - это отдельная команда.
</b></details>

<details>
<summary>В чем разница между <code>someMultiLineString: |</code> и <code>someMultiLineString: ></code>? </summary><br><b>

Использование `>` заставит многострочную строку свернуться в одну строку

```
someMultiLineString: >
  Это на самом деле
  одна линия
  не позволяйте внешности обмануть вас
```
</b></details>

<details>
<summary>Что такое заполнители в YAML?</summary><br><b>

Они позволяют ссылаться на значения вместо их непосредственной записи и используются следующим образом:

```
имя пользователя: {{ my.user_name }}
```
</b></details>

<details>
<summary>Как определить несколько компонентов YAML в одном файле?</summary><br><b>

Используя это: `---`
Примеры:

```
номер_документа: 1
---
номер_документа: 2
```
</b></details>

#### Встроенное ПО

<details>
<summary>Объясните, что такое микропрограмма</summary><br><b>

[Википедия](https://en.wikipedia.org/wiki/Firmware): "В вычислительной технике микропрограмма - это особый класс компьютерного программного обеспечения, обеспечивающий низкоуровневое управление конкретным аппаратным обеспечением устройства. Микропрограммы, такие как BIOS персонального компьютера, могут содержать основные функции устройства и предоставлять услуги по абстрагированию аппаратного обеспечения для программ более высокого уровня, таких как операционные системы."
</b></details>

#### Клиенты и поставщики услуг

<details>
<summary>Что такое SLO (цель уровня обслуживания)?</summary><br><b>
</b></details>

<details>
<summary>Что такое SLA (соглашение об уровне обслуживания)? </summary><br><b>
</b></details>

## Jira

<details>
<summary>Объяснение/демонстрация следующих типов в Jira:

  * Эпический
  * История
  * Задача</summary><br><b>
</b></details>

<details>
<summary>Что такое проект в Jira? </summary><br><b>
</b></details>

## Кафка

<details>
<summary>Что такое Kafka?</summary><br><b>
</b></details>

<details>
<summary>В Kafka, как автоматически сбалансировать лидерство брокеров разделов в кластере?

  * Включить автоматические выборы лидера и уменьшить дисбаланс
процентное соотношение
  * Ручная ребалансировка с помощью kafkat
  * Настроить group.initial.rebalance.delay.ms на 3000
  * Все вышеперечисленное
</summary><br><b>
</b></details>

## Кассандра

<details>
<summary>Как часто при управлении кластером cassandra вам нужно запускать nodetool repair для поддержания согласованности кластера?

  * В рамках рубрикиСемья ГК-грация Раз в неделю
  * Меньше, чем минимальное количество байт уплотненного раздела
  * Зависит от стратегии уплотнения
</summary><br><b>
</b></details>

## HTTP

<details>
<summary>Что такое HTTP?</summary><br><b>
</b></details>

<details>
<summary>Описание жизненного цикла HTTP запроса</summary><br><b>

* Разрешение хоста путем запроса к DNS-резольверу
* Клиент SYN
* Сервер SYN+ACK
* Клиент SYN
* HTTP-запрос
* HTTP-ответ
</b></details>

<details>
<summary>Истина или ложь? HTTP является государственным</summary><br><b>

Ложь. Он не сохраняет состояние для входящего запроса.
</b></details>

<details>
<summary>Как выглядит HTTP запрос?</summary><br><b>

Она состоит из:

 * Строка запроса - тип запроса
 * Заголовки - информация о содержимом, например, длина, кодировка и т.д.
 * Тело (не всегда включено)
</b></details>

<details>
<summary>Какие типы методов HTTP существуют?</summary><br><b>

* GET
* POST
* HEAD
* PUT
* DELETE
* CONNECT
* ВАРИАНТЫ
* TRACE
</b></details>

<details>
<summary>Какие бывают коды ответов HTTP?</summary><br><b>

* 1xx - информационный
* 2xx - Успех
* 3xx - перенаправление
* 4xx - Ошибка, ошибка клиента
* 5xx - Ошибка, сбой сервера
</b></details>

<details>
<summary>Что такое HTTPS?</summary><br><b>
</b></details>

<details>
<summary>Объяснение HTTP Cookies</summary><br><b>

HTTP не имеет состояния. Для обмена информацией о состоянии мы можем использовать Cookies.

TODO: объяснить, что на самом деле является Cookie
</b></details>

<details>
<summary>Что такое HTTP Pipelining? </summary><br><b>
</b></details>

<details>
<summary>Вы получаете ошибку "504 Gateway Timeout" от HTTP-сервера. Что это значит? </summary><br><b>

Сервер не получил своевременно ответ от другого сервера, с которым он взаимодействует.
</b></details>

<details>
<summary>Что такое прокси? </summary><br><b>
</b></details>

<details>
<summary>Что такое обратный прокси-сервер?</summary><br><b>
</b></details>

<details>
<summary>Что такое CDN? </summary><br><b>
</b></details>

<details>
<summary>Когда вы публикуете проект, вы обычно публикуете его с лицензией. С какими типами лицензий вы знакомы и какую предпочитаете использовать? </summary><br><b>
</b></details>

<details>
<summary>Объясняет, что такое "X-Forwarded-For"</summary><br><b>

[Википедия](https://en.wikipedia.org/wiki/X-Forwarded-For): "Поле HTTP-заголовка X-Forwarded-For (XFF) является общим методом идентификации IP-адреса клиента, подключающегося к веб-серверу через HTTP-прокси или балансировщик нагрузки".
</b></details>

#### Балансировщики нагрузки

<details>
<summary>Что такое балансировщик нагрузки? </summary><br><b>

Балансировщик нагрузки принимает (или отклоняет) входящий сетевой трафик от клиента и на основе некоторых критериев (связанных с приложением, сетью и т.д.) распределяет эти соединения между серверами (по крайней мере, одним).
</b></details>

<details>
<summary>Зачем использовать балансировщик нагрузки?</summary><br><b>

* Масштабируемость - используя балансировщик нагрузки, вы можете добавить больше серверов в бэкенд, чтобы обрабатывать больше запросов/трафика от клиентов, в отличие от использования одного сервера.
* Избыточность - если один сервер в бэкенде умирает, балансировщик нагрузки будет продолжать перенаправлять трафик/запросы на второй сервер, так что пользователи даже не заметят, что один из серверов в бэкенде не работает.
</b></details>

<details>
<summary>С какими техниками/алгоритмами балансировки нагрузки вы знакомы? </summary><br><b>

  * Раунд Робин
  * Взвешенный раунд-робин
  * Наименьшая связь
  * Взвешенное наименьшее соединение
  * Основанные на ресурсах
  * Фиксированное взвешивание
  * Взвешенное время отклика
  * IP-хэш источника
  * URL Hash
</b></details>

<details>
<summary>Каковы недостатки алгоритма round robin в балансировке нагрузки?</summary><br><b>

  * Простой алгоритм round robin ничего не знает о нагрузке и спецификации каждого сервера, на который он направляет запросы. Возможно, что несколько запросов с большой нагрузкой попадут на один сервер, в то время как другие серверы получат только легкие запросы, что приведет к тому, что один сервер будет выполнять большую часть работы, возможно, даже рухнет в какой-то момент, потому что он не сможет самостоятельно обработать все запросы с большой нагрузкой.
  * Каждый запрос от клиента создает совершенно новую сессию. Это может быть проблемой для определенных сценариев, когда вы хотите выполнить несколько операций, где сервер должен знать о результате операции, то есть, по сути, быть в курсе истории, которую он имеет с клиентом. В режиме round robin первый запрос может попасть на сервер X, а второй запрос может попасть на сервер Y и попросить продолжить обработку данных, которые уже были обработаны на сервере X.
</b></details>

<details>
<summary>Что такое балансировщик нагрузки приложений? </summary><br><b>
</b></details>

<details>
<summary>В каких сценариях вы бы использовали ALB? </summary><br><b>
</b></details>

<details>
<summary>На каких уровнях может работать балансировщик нагрузки?</summary><br><b>

L4 и L7
</b></details>

<details>
<summary>Можно ли выполнить балансировку нагрузки без использования выделенного экземпляра балансировщика нагрузки?</summary><br><b>

Да, вы можете использовать DNS для выполнения балансировки нагрузки.
</b></details>

<details>
<summary>Что такое балансировка нагрузки DNS? Каковы ее преимущества? Когда вы будете ее использовать? </summary><br><b>
</b></details>

#### Балансировщики нагрузки - "липкие" сессии

<details>
<summary>Что такое липкие сессии? В чем их плюсы и минусы? </summary><br><b>

Рекомендуем прочитать:
  * [Статья Red Hat](https://access.redhat.com/solutions/900933)

Конс:
  * Может вызвать неравномерную нагрузку на инстанцию (поскольку запросы направляются к одним и тем же инстанциям).
Плюсы:
  * Обеспечивает, чтобы сессии в процессе не терялись при создании нового запроса
</b></details>

<details>
<summary>Назовите один случай использования липких сессий</summary><br><b>

Вы хотите убедиться, что пользователь не потеряет данные текущей сессии.
</b></details>

<details>
<summary>Что используют липкие сессии для включения "липкости"?</summary><br><b>

Файлы cookie. Существуют файлы cookie, основанные на приложениях, и файлы cookie, основанные на продолжительности.
</b></details>

<details>
<summary>Объяснение файлов cookie на основе приложений</summary><br><b>

* Генерируется приложением и/или балансировщиком нагрузки
* Обычно позволяет включать пользовательские данные
</b></details>

<details>
<summary>Объяснение файлов cookie, основанных на продолжительности</summary><br><b>

* Генерируется балансировщиком нагрузки
* Сессия больше не является липкой после истечения ее продолжительности
</b></details>

#### Балансировщики нагрузки - Алгоритмы балансировки нагрузки

<details>
<summary>Объясните каждый из следующих методов балансировки нагрузки

  * Раунд Робин
  * Взвешенный раунд-робин
  * Наименьшая связь
  * Взвешенное наименьшее соединение
  * Основанные на ресурсах
  * Фиксированное взвешивание
  * Взвешенное время отклика
  * IP-хэш источника
  * URL Hash
</summary><br><b>
</b></details>

<details>
<summary>Объясните пример использования для слива соединения?</summary><br><b>
Чтобы гарантировать, что классический балансировщик нагрузки прекратит отправку запросов к экземплярам, которые прекращают регистрацию или нездоровы, сохраняя при этом существующие соединения открытыми, используйте функцию осушения соединений. Это позволяет балансировщику нагрузки завершать запросы, отправленные к экземплярам, которые прекращают регистрацию или нездоровы.

Максимальное значение тайм-аута может быть установлено в диапазоне от 1 до 3600 секунд как на GCP, так и на AWS.

</b></details>

#### Лицензии

<details>
<summary>Вы знакомы с "Creative Commons"? Что вы знаете о нем? </summary><br><b>
</b></details>

<details>
<summary>Объясните различия между авторским левом и разрешительными лицензиями</summary><br><b>

При авторском леве любая производная работа должна использовать ту же лицензию, в то время как при разрешительном лицензировании таких условий нет. GPL-3 - пример лицензии с авторским левом, а BSD - пример разрешительной лицензии.
</b></details>

#### Случайный

<details>
<summary>Как работает поисковая система?</summary><br><b>
</b></details>

<details>
<summary>Как работает автозавершение?</summary><br><b>
</b></details>

<details>
<summary>Что быстрее оперативной памяти?</summary><br><b>

Кэш процессора.
[Источник](https://www.enterprisestorageforum.com/hardware/cache-memory/)
</b></details>

<details>
<summary>Что такое утечка памяти?</summary><br><b>
</b></details>

<details>
<summary>Какой ваш любимый протокол? </summary><br><b>

SSH
HTTP
DHCP
DNS
...
</b></details>

<details>
<summary>Что такое Cache API?</summary><br><b>
</b></details>

<details>
<summary>Что такое проблема C10K? Актуальна ли она сегодня? </summary><br><b>

https://idiallo.com/blog/c10k-2016
</b></details>

## Хранилище

<details>
<summary>Какие существуют типы форматов хранения данных?</summary><br><b>

  * Файл
  * Блок
  * Объект
</b></details>

<details>
<summary>Какие существуют типы устройств хранения данных?</summary><br><b>
</b></details>

<details>
<summary>Объяснение IOPS</summary><br><b>
</b></details>

<details>
<summary>Объяснение пропускной способности хранилища</summary><br><b>
</b></details>

<details>
<summary>Что такое файловая система?</summary><br><b>
</b></details>

<details>
<summary>Объяснение темных данных</summary><br><b>
</b></details>

## Вопросы, которые вы можете задать

<a name="questions-you-ask"></a>

Список вопросов, которые вы как кандидат можете задать интервьюеру во время или после собеседования.
Это всего лишь рекомендации, используйте их осторожно. Не каждый интервьюер сможет ответить на эти вопросы (или будет рад ответить), что, возможно, должно быть тревожным сигналом для вас относительно работы в таком месте, но это зависит от вас.

<details>
<summary>Что вам нравится в работе здесь?</summary><br><b>
</b></details>

<details>
<summary>Как компания способствует личностному росту?</summary><br><b>
</b></details>

<details>
<summary>Каков текущий уровень технического долга, с которым вы имеете дело? </summary><br><b>

Будьте осторожны, задавая этот вопрос - все компании, независимо от размера, имеют тот или иной уровень технического долга.
Сформулируйте вопрос в том свете, что все компании имеют дело с этим, но вы хотите увидеть текущую
болевые точки, с которыми они сталкиваются <br>

Это отличный способ выяснить, как менеджеры справляются с незапланированной работой, и насколько хорошо они это делают.
установление ожиданий в отношении проектов.
</b></details>

<details>
<summary>Почему я НЕ должен к вам присоединиться? (или "что вам не нравится в работе здесь?")</summary><br><b>
</b></details>

<details>
<summary>Какой ваш любимый проект, над которым вы работали?</summary><br><b>

Это может дать вам представление о некоторых крутых проектах, над которыми работает компания, и если
вам понравится работать над подобными проектами. Это также хороший способ проверить, не
руководители позволяют сотрудникам учиться и развиваться, реализуя проекты за пределами компании.
обычная работа, которую вы бы делали.
</b></details>

<details>
<summary>Если бы вы могли изменить что-то одно в своей повседневной жизни, что бы это было? </summary><br><b>

Как и в случае с вопросом о технических долгах, это поможет вам выявить все болевые точки компании.
Кроме того, это может стать отличным способом показать, как вы будете полезны команде.<br>

Например, если они упоминают, что у них есть проблема X, а вы уже решали ее в прошлом,
вы можете показать, как вы сможете смягчить эту проблему.
</b></details>

<details>
<summary>Допустим, мы договорились, и вы нанимаете меня на эту должность, через X месяцев, чего вы ожидаете от меня? </summary><br><b>

Это не только подскажет вам, чего от вас ждут, но и даст большую подсказку о том, какую работу вам предстоит выполнять в первые месяцы работы.
</b></details>

## Тестирование

<details>
<summary>Объяснение тестирования "белого ящика"</summary><br><b>
</b></details>

<details>
<summary>Объяснение тестирования "черного ящика"</summary><br><b>
</b></details>

<details>
<summary>Что такое модульные тесты?</summary><br><b>
</b></details>

<details>
<summary>Какие типы тестов вы бы запустили для тестирования веб-приложения?</summary><br><b>
</b></details>

<details>
<summary>Объяснение тестового жгута? </summary><br><b>
</b></details>

<details>
<summary>Что такое A/B тестирование?</summary><br><b>
</b></details>

<details>
<summary>Что такое сетевое моделирование и как его проводить?</summary><br><b>
</b></details>

<details>
<summary>С какими типами тестов представлений вы знакомы? </summary><br><b>
</b></details>

<details>
<summary>Объясните следующие типы тестов:

  * Нагрузочное тестирование
  * Стресс-тестирование
  * Тестирование емкости
  * Объемное тестирование
  * Испытание на выносливость
</summary><br><b>
</b></details>

## Базы данных

|Name|Topic|Objective & Instructions|Solution|Comments|
|--------|--------|------|----|----|
| Таблицы доски объявлений | Таблицы реляционных БД | [Упражнение](exercises/databases/table_for_message_board_system.md) | [Решение](exercises/databases/solutions/table_for_message_board_system.md)

<details>
<summary>Что такое реляционная база данных?</summary><br><b>

  * Хранение данных: система для хранения данных в таблицах
  * SQL: язык программирования для управления реляционными базами данных
  * Язык определения данных: стандартный синтаксис для создания, изменения и удаления таблиц.
</b></details>

<details>
<summary>Что означает, когда база данных соответствует стандарту ACID? </summary><br>

ACID расшифровывается как Atomicity, Consistency, Isolation, Durability. Для того чтобы база данных соответствовала стандарту ACID, она должна отвечать каждому из четырех критериев

**Атомарность** - Когда в базе данных происходит изменение, оно должно быть либо успешным, либо неудачным в целом.

Например, если вы хотите обновить таблицу, обновление должно быть выполнено полностью. Если оно будет выполнено только частично, то будет выполнена команда
обновление считается неудачным в целом и не будет выполнено - БД вернется в исходное состояние
состояние до того, как произошло обновление. Следует также упомянуть, что Atomicity гарантирует, что каждый
транзакция завершается как самостоятельная "единица" - если какая-либо часть не работает, то не работает все заявление.

**Согласованность** - любое изменение, внесенное в базу данных, должно перевести ее из одного допустимого состояния в другое.

Например, если вы внесете изменения в БД, это не должно привести к ее повреждению. Согласованность поддерживается проверками и ограничениями, которые
предварительно определены в БД. Например, если вы попытались изменить значение со строки на int, когда столбец
должен иметь тип данных string, последовательная БД не позволит этой транзакции пройти, и действие будет
не исполняться

**Изоляция** - это гарантирует, что база данных никогда не будет замечена "в середине обновления" - так как несколько транзакций выполняются одновременно.
в то же время, он должен оставить БД в том же состоянии, как если бы транзакции выполнялись последовательно.

Например, допустим, что 20 других людей одновременно вносят изменения в базу данных. В
когда вы выполнили запрос, 15 из 20 изменений уже прошли, но 5 все еще находились в процессе. Вы должны
вы увидите только 15 завершенных изменений - вы не увидите базу данных в середине обновления по мере прохождения изменений.

**Долговечность** - После того, как изменения приняты, они останутся принятыми независимо от того, что происходит
(отключение питания, сбой системы и т.д.). Это означает, что все завершенные транзакции
должны быть записаны в энергонезависимую память.

Обратите внимание, что SQL по своей природе совместим с ACID. Некоторые NoSQL СУБД могут быть ACID-совместимыми в зависимости от
как они работают, но, по общему правилу, NoSQL СУБД не считаются ACID-совместимыми
</details>

<details>
<summary>Что такое шардинг? </summary><br><b>

Шардинг - это горизонтальное разделение.

Можете ли вы объяснить, чем он полезен?
</b></details>

<details>
<summary>Вы обнаружили, что ваша база данных стала узким местом, и пользователи испытывают проблемы с доступом к данным. Как вы можете справиться с такой ситуацией? </summary><br><b>

Мало информации о том, почему он стал узким местом и какова текущая архитектура, поэтому один общий подход может быть<br>.
для снижения нагрузки на базу данных путем перемещения часто используемых данных в структуру в памяти.
</b></details>

<details>
<summary>Что такое пул соединений? </summary><br><b>

Пул соединений - это кэш соединений базы данных, который используется для того, чтобы избежать накладных расходов на создание соединения для каждого запроса к базе данных.
</b></details>

<details>
<summary>Что такое утечка соединения?</summary><br><b>

Утечка соединения - это ситуация, когда соединение с базой данных не закрывается после создания и больше не нужно.
</b></details>

<details>
<summary>Что такое блокировка таблицы? </summary><br><b>
</b></details>

<details>
<summary>Ваша база данных работает медленнее, чем обычно. Точнее, ваши запросы занимают много времени. Что бы вы сделали? </summary><br><b>

* Запросы на выполнение и отмена неактуальных запросов
* Проверка утечки соединений (запрос на наличие запущенных соединений и включение их IP)
* Проверка блокировок таблиц и уничтожение неактуальных сеансов блокировки.
</b></details>

<details>
<summary>Что такое хранилище данных?</summary><br><b>

"Хранилище данных - это предметно-ориентированная, интегрированная, изменяющаяся во времени и энергонезависимая коллекция данных для поддержки процесса принятия решений в организации".
</b></details>

<details>
<summary>Объясните, что такое база данных временных рядов</summary><br><b>
</b></details>

<details>
<summary>Что такое OLTP (Online transaction processing)? </summary><br><b>
</b></details>

<details>
<summary>Что такое OLAP (Online Analytical Processing)? </summary><br><b>
</b></details>

<details>
<summary>Что такое индекс в базе данных?</summary><br><b>

Индекс базы данных - это структура данных, которая повышает скорость выполнения операций в таблице. Индексы могут быть созданы на основе одного или нескольких столбцов, обеспечивая основу как для быстрого произвольного поиска, так и для эффективного упорядочивания доступа к записям.
</b></details>

<details>
<summary>Какие типы данных существуют в реляционных базах данных?</summary><br><b>
</b></details>

<details>
<summary>Объяснение нормализации</summary><br><b>

Данные, которые многократно используются в базе данных, должны храниться один раз и ссылаться на них с помощью внешнего ключа.<br>
Это имеет очевидное преимущество в простоте обслуживания, когда вам нужно изменить значение только в одном месте, чтобы изменить его везде.
</b></details>

<details>
<summary>Объясните первичный ключ и внешний ключ</summary><br><b>

Первичный ключ: каждая строка в каждой таблице должна иметь уникальный идентификатор, который представляет эту строку.<br>
Внешний ключ: ссылка на первичный ключ другой таблицы. Это позволяет объединять таблицы вместе, чтобы получить всю необходимую информацию без дублирования данных.
</b></details>

<details>
<summary>Какие типы таблиц данных вы использовали? </summary><br><b>

  * Таблица первичных данных: основные данные, о которых вы заботитесь
  * таблица Details: включает внешний ключ и имеет отношения один ко многим
  * Таблица значений поиска: может быть одной таблицей для каждого поиска или таблицей, содержащей все поиски и имеющей отношения один ко многим.
  * Мультисправочная таблица
</b></details>

<details>
<summary>Что такое ORM? Какие преимущества он дает при использовании реляционных баз данных? </summary><br><b>

[Википедия](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping): "это техника программирования для преобразования данных между несовместимыми системами типов с помощью объектно-ориентированных языков программирования".

Что касается реляционных баз данных:

  * База данных как код
  * Абстракция базы данных
  * Инкапсулирует сложность SQL
  * Обеспечивает процесс обзора кода
  * Позволяет использовать в качестве собственной ООП-структуры
</b></details>

<details>
<summary>Что такое DDL?</summary><br><b>

[Википедия](https://en.wikipedia.org/wiki/Data_definition_language): "В контексте SQL, определение данных или язык описания данных (DDL) - это синтаксис для создания и изменения объектов базы данных, таких как таблицы, индексы и пользователи."
</b></details>

## Regex

Получив текстовый файл, выполните следующие упражнения

#### Экстракт

<details>
<summary>Извлечение всех чисел</summary><br><b>
</b></details>

<details>
<summary>Извлечение первого слова каждой строки</summary><br><b>

Бонус: извлечение последнего слова каждой строки
</b></details>

<details>
<summary>Извлечение всех IP-адресов</summary><br><b>
</b></details>

<details>
<summary>Извлечение дат в формате yyyy-mm-dd или yyyy-dd-mm</summary><br><b>.
</b></details>

<details>
<summary>Извлечение адресов электронной почты</summary><br><b>
</b></details>

#### Заменить

<details>
<summary>Заменить табуляцию четырьмя пробелами</summary><br><b>
</b></details>

<details>
<summary>Замените "красный" на "зеленый"</summary><br><b>
</b></details>

## Дизайн системы

<details>
<summary>Объясните, что такое "единая точка отказа"?</summary><br><b>
</b></details>

<details>
<summary>Объяснение "3-уровневой архитектуры" (включая плюсы и минусы)</summary><br><b>
</b></details>

<details>
<summary>Каковы недостатки монолитной архитектуры?</summary><br><b>

* Не подходит для частых изменений кода и возможности развертывания новых функций
* Не предназначены для современной инфраструктуры (например, публичных облаков)
* Масштабирование команды для работы с монолитной архитектурой является более сложной задачей.
</b></details>

<details>
<summary>Каковы преимущества архитектуры микросервисов перед монолитной архитектурой?</summary><br><b>

* Каждый из сервисов по отдельности выходит из строя, не перерастая в отказ всего приложения.
* Каждая услуга может разрабатываться и поддерживаться отдельной командой, и эта команда может выбрать свои собственные инструменты и язык кодирования
</b></details>

<details>
<summary>Что такое сервисная сетка? </summary><br><b>

[В этой статье] (https://www.redhat.com/en/topics/microservices/what-is-a-service-mesh) дается отличное объяснение.
</b></details>

<details>
<summary>Объясните "Свободное соединение"</summary><br><b>
</b></details>

<details>
<summary>Что такое очередь сообщений? Когда она используется? </summary><br><b>
</b></details>

#### Масштабируемость

<details>
<summary>Объяснить масштабируемость</summary><br><b>

Возможность легко увеличивать размер и мощность в зависимости от спроса и использования.
</b></details>

<details>
<summary>Объяснение эластичности</summary><br><b>

Способность к росту, но также и к сокращению в зависимости от того, что требуется
</b></details>

<details>
<summary>Объяснение аварийного восстановления</summary><br><b>
</b></details>

<details>
<summary>Объяснение отказоустойчивости и высокой доступности</summary><br><b>

Отказоустойчивость - способность к самовосстановлению и возвращению к нормальной производительности. Также способность выдерживать сбой и сохранять работоспособность.

Высокая доступность - возможность доступа к ресурсу (в некоторых случаях использования, используя различные платформы).
</b></details>

<details>
<summary>В чем разница между высокой доступностью и аварийным восстановлением? </summary><br><b>

[wintellect.com](https://www.wintellect.com/high-availability-vs-disaster-recovery): "Высокая доступность, проще говоря, это устранение единичных точек отказа, а аварийное восстановление - это процесс возвращения системы в рабочее состояние, когда система становится неработоспособной. По сути, восстановление после сбоя высокой доступности подхватывается, поэтому сначала HA".
</b></details>

<details>
<summary>Объяснение вертикального масштабирования</summary><br><b>

Вертикальное масштабирование - это процесс добавления ресурсов для увеличения мощности существующих серверов. Например, добавление большего количества процессоров, увеличение объема оперативной памяти и т.д.
</b></details>

<details>
<summary>Каковы недостатки вертикального масштабирования?</summary><br><b>

При вертикальном масштабировании компонент все равно остается единой точкой отказа.
Кроме того, у него есть аппаратное ограничение, и если у вас нет больше ресурсов, вы не сможете масштабироваться по вертикали.
</b></details>

<details>
<summary>Какой тип облачных сервисов обычно поддерживает вертикальное масштабирование?</summary><br><b>

Базы данных, кэш. Это характерно в основном для нераспределенных систем.
</b></details>

<details>
<summary>Объяснить горизонтальное масштабирование</summary><br><b>

Горизонтальное масштабирование - это процесс добавления большего количества ресурсов, которые смогут обрабатывать запросы как единое целое
</b></details>

<details>
<summary>В чем недостаток горизонтального масштабирования? Что часто требуется для выполнения горизонтального масштабирования? </summary><br><b>

Балансировщик нагрузки. Вы можете добавить больше ресурсов, но если вы хотите, чтобы они участвовали в процессе, вы должны обслуживать их запросы/ответы.
Кроме того, при горизонтальном масштабировании возникает проблема несогласованности данных.
</b></details>

<details>
<summary>Объясните, в каких случаях вы будете использовать вертикальное масштабирование, а в каких - горизонтальное</summary><br><b>
</b></details>

<details>
<summary>Объясните, что такое устойчивость и какие существуют способы сделать систему более устойчивой</summary><br><b>
</b></details>

<details>
<summary>Объяснение "последовательного хэширования"</summary><br><b>
</b></details>

<details>
<summary>Как бы вы обновили каждый из сервисов на следующем рисунке без простоя приложения (foo.com)?<br>
<img src="images/design/cdn-no-downtime.png" width="300x;" height="400px;"/>
</summary><br><b>
</b></details>

<details>
<summary>В чем проблема следующей архитектуры и как бы вы ее исправили?<br>
<img src="images/design/producers_consumers_issue.png" width="400x;" height="300px;"/>
</summary><br><b>

Нагрузка на производителей или потребителей может быть высокой, что приведет к их зависанию или сбою.<br>
Вместо того чтобы работать в режиме "push mode", потребители могут получать задания только тогда, когда они готовы их обрабатывать. Это можно исправить, используя потоковую платформу, такую как Kafka, Kinesis и т. д. Эта платформа позаботится о том, чтобы справиться с высокой нагрузкой/трафиком и передавать задачи/сообщения потребителям только тогда, когда они готовы их получить.

<img src="images/design/producers_consumers_fix.png" width="300x;" height="200px;"/>
</b></details>

<details>
<summary>Пользователи сообщают, что при добавлении небольшого количества данных на вход происходит огромный скачок во времени обработки. В чем может быть проблема? <br>
<img src="images/design/input-process-output.png" width="300x;" height="200px;"/>
</summary><br><b>
</b></details>

<details>
<summary>Как бы вы масштабировали архитектуру из предыдущего вопроса до сотен пользователей?</summary><br><b>
</b></details>

#### Кэш

<details>
<summary>Что такое "кэш"? В каких случаях вы будете его использовать? </summary><br><b>
</b></details>

<details>
<summary>Что такое "распределенный кэш"?</summary><br><b>
</b></details>

<details>
<summary>Что такое "политика замены кэша"? </summary><br><b>

Посмотрите [здесь] (https://en.wikipedia.org/wiki/Cache_replacement_policies)
</b></details>

<details>
<summary>С какими политиками замены кэша вы знакомы? </summary><br><b>

Вы можете найти список [здесь] (https://en.wikipedia.org/wiki/Cache_replacement_policies)
</b></details>

<details>
<summary>Объясните следующие политики кэширования:

  * FIFO
  * LIFO
  * LRU</summary><br><b>

Читайте об этом [здесь](https://en.wikipedia.org/wiki/Cache_replacement_policies)
</b></details>

<details>
<summary>Почему бы не записывать все в кэш вместо базы данных/хранилища данных?</summary><br><b>
</b></details>

#### Миграции

<details>
<summary>Как подготовиться к миграции? (или планируете миграцию)</summary><br><b>

Вы можете упомянуть:

откат и перемотка вперед
перерезать
генеральные репетиции
Перенаправление DNS
</b></details>

<details>
<summary>Объяснение техники "Ветвление через абстракцию"</summary><br><b>
</b></details>

#### Проектирование системы

<details>
<summary>Можете ли вы разработать сайт потокового видео? </summary><br><b>
</b></details>

<details>
<summary>Вы можете разработать сайт для загрузки фотографий? </summary><br><b>
</b></details>

<details>
<summary>Как построить укорачиватель URL? </summary><br><b>
</b></details>

#### Больше вопросов по проектированию систем

Дополнительные упражнения можно найти в [репозитории system-design-notebook](https://github.com/bregman-arie/system-design-notebook).

<p align="center"><a href="https://github.com/bregman-arie/system-design-notebook"><img src="images/system_design_notebook.png"/></a></p>

## Hardware

<details>
<summary>Что такое процессор? </summary><br><b>

Центральный процессор (ЦП) выполняет основные арифметические, логические, управляющие операции и операции ввода/вывода (I/O), заданные инструкциями в программе. Он отличается от внешних компонентов, таких как основная память и схемы ввода/вывода, и специализированных процессоров, таких как графические процессоры (GPU).
</b></details>

<details>
<summary>Что такое оперативная память?</summary><br><b>

Оперативная память (RAM, Random Access Memory) - это аппаратное обеспечение вычислительного устройства, в котором хранятся операционная система (ОС), прикладные программы и данные, используемые в данный момент, чтобы к ним мог быстро обратиться процессор устройства. Оперативная память - это основная память в компьютере. Считывание и запись данных из нее происходит гораздо быстрее, чем из других видов памяти, таких как жесткий диск (HDD), твердотельный накопитель (SSD) или оптический привод.
</b></details>

<details>
<summary>Что такое встраиваемая система?</summary><br><b>

Встроенная система - это компьютерная система - комбинация компьютерного процессора, компьютерной памяти и периферийных устройств ввода/вывода, - которая выполняет специальную функцию в рамках более крупной механической или электронной системы. Она встраивается как часть целого устройства, часто включающего электрическое или электронное оборудование и механические детали. 
</b></details>

<details>
<summary>Можете ли вы привести пример встраиваемой системы?</summary><br><b>

Raspberry Pi
</b></details>

<details>
<summary>Какие типы хранения существуют?</summary><br><b>
</b></details>

## Большие данные

<details>
<summary>Объясните, что такое Большие данные</summary><br><b>

По определению Дуга Лейни:

* Объем: Чрезвычайно большие объемы данных
* Скорость: Реальное время, пакетная обработка, потоки данных
* Разнообразие: Различные формы данных, структурированные, полуструктурированные и неструктурированные.
* Достоверность или изменчивость: Непоследовательные, иногда неточные, меняющиеся данные
</b></details>

<details>
<summary>Что такое DataOps? Как он связан с DevOps? </summary><br><b>

 DataOps стремится сократить время сквозного цикла анализа данных - от зарождения идей до буквального создания графиков, диаграмм и моделей, создающих ценность. 
 DataOps объединяет Agile-разработку, DevOps и статистический контроль процессов и применяет их к аналитике данных.
</b></details>

<details>
<summary>Что такое архитектура данных? </summary><br><b>

Ответ от [talend.com](https://www.talend.com/resources/what-is-data-architecture):

"Архитектура данных - это процесс стандартизации того, как организации собирают, хранят, преобразуют, распространяют и используют данные. Цель состоит в том, чтобы предоставлять необходимые данные людям, которым они нужны, когда они им нужны, и помогать им разобраться в них".
</b></details>

<details>
<summary>Объяснение различных форматов данных</summary><br><b>

* Структурированные - данные, имеющие определенный формат и длину (например, числа, слова).
* Полуструктурированный - не соответствует определенному формату, но является самоописывающимся (например, XML, SWIFT).
* Неструктурированный - не соответствует определенному формату (например, изображения, тестовые сообщения)
</b></details>

<details>
<summary>Что такое хранилище данных?</summary><br><b>

[Wikipedia's explanation on Data Warehouse](https://en.wikipedia.org/wiki/Data_warehouse)
[объяснение Amazon о хранилище данных](https://aws.amazon.com/data-warehouse)
</b></details>

<details>
<summary>Что такое Data Lake? </summary><br><b>

[Data Lake - Wikipedia](https://en.wikipedia.org/wiki/Data_lake)
</b></details>

<details>
<summary>Можете ли вы объяснить разницу между озером данных и хранилищем данных? </summary><br><b>
</b></details>

<details>
<summary>Что такое "версионирование данных"? Какие существуют модели "версионирования данных"? </summary><br><b>
</b></details>

<details>
<summary>Что такое ETL? </summary><br><b>
</b></details>

#### Apache Hadoop

<details>
<summary>Объясните, что такое Hadoop</summary><br><b>

[Apache Hadoop - Википедия](https://en.wikipedia.org/wiki/Apache_Hadoop)
</b></details>

<details>
<summary>Объяснение Hadoop YARN</summary><br><b>

Отвечает за управление вычислительными ресурсами в кластерах и планирование приложений пользователей
</b></details>

<details>
<summary>Объяснение Hadoop MapReduce</summary><br><b>

Модель программирования для обработки крупномасштабных данных
</b></details>

<details>
<summary>Объяснение распределенных файловых систем Hadoop (HDFS)</summary><br><b>

* Распределенная файловая система, обеспечивающая высокую совокупную пропускную способность в кластере.
* Для пользователя она выглядит как обычная структура файловой системы, но за кулисами она распределена между несколькими машинами в кластере.
* Типичный размер файла составляет ТБ, и он может масштабироваться и поддерживать миллионы файлов.
* Он отказоустойчив, что означает, что он обеспечивает автоматическое восстановление после сбоев.
* Он лучше всего подходит для выполнения длительных пакетных операций, а не для анализа в реальном времени.
</b></details>

<details>
<summary>Что вы знаете об архитектуре HDFS? </summary><br><b>

[Архитектура HDFS](http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html)

* Архитектура "ведущий-ведомый
* Namenode - ведущий, Datanodes - ведомые.
* Файлы разбиты на блоки
* Блоки, хранящиеся на датанодах
* Namenode контролирует все метаданные
</b></details>

## Ceph

<details>
<summary>Объяснение того, что такое Ceph</summary><br><b>
</b></details>

<details>
<summary>Правда или ложь? Ceph предпочитает последовательность и корректность производительности</summary><br><b>
Правда
</b></details>

<details>
<summary>Какие сервисы или типы хранилищ поддерживает Ceph?</summary><br><b>

* Объект (RGW)
* Блок (RBD)
* Файл (CephFS)
</b></details>

<details>
<summary>Что такое RADOS? </summary><br><b>

* Надежное автономное распределенное хранилище объектов
* Предоставляет низкоуровневый сервис хранения объектов данных
* Сильная последовательность
* Упрощает разработку и реализацию более высоких уровней (блок, файл, объект).
</b></details>

<details>
<summary>Описание компонентов программного обеспечения RADOS</summary><br><b>

* Монитор
  * Центральный орган для аутентификации, размещения данных, политики
  * Координационный пункт для всех других компонентов кластера
  * Защита критического состояния кластера с помощью Paxos
* Менеджер
  * Агрегирует показатели реального времени (пропускная способность, использование диска и т.д.).
  * Хост для подключаемых функций управления
  * 1 активный, 1+ резервный на кластер
* OSD (Object Storage Daemon)
  * Хранение данных на жестком или твердотельном диске.
  * Обслуживание клиентских запросов ввода-вывода
</b></details>

<details>
<summary>Каков рабочий процесс получения данных из Ceph? </summary><br><b>
</b></details>

<details>
<summary>Каков рабочий процесс получения данных из Ceph? </summary><br><b>
</b></details>

<details>
<summary>Что такое "Группы размещения"? </summary><br><b>
</b></details>

<details>
<summary>Подробно опишите следующее: Объекты -> Пул -> Группы размещения -> OSDs</summary><br><b>
</b></details>

<details>
<summary>Что такое OMAP? </summary><br><b>
</b></details>

<details>
<summary>Что такое сервер метаданных? Как он работает? </summary><br><b>
</b></details>

## Packer

<details>
<summary>Что такое Packer? Для чего он используется? </summary><br><b>

В целом, Packer автоматизирует создание образов машин.
Это позволяет сосредоточиться на конфигурации до развертывания при создании образов. В большинстве случаев это позволяет запускать экземпляры гораздо быстрее.
</b></details>

<details>
<summary>Packer следует модели "конфигурация->развертывание" или "развертывание->конфигурация"?</summary><br><b>

Конфигурация->развертывание, которая имеет некоторые преимущества, такие как:

1. Скорость развертывания - вы настраиваете один раз перед развертыванием вместо того, чтобы настраивать каждый раз при развертывании. Это позволяет запускать экземпляры/сервисы гораздо быстрее.
2. Более неизменяемая инфраструктура - при конфигурации->развертывании маловероятно иметь очень разные развертывания, поскольку большая часть конфигурации выполняется до развертывания. В этой модели такие проблемы, как ошибки зависимостей, обрабатываются/обнаруживаются до развертывания.
</b></details>

## Сертификаты

Если вы ищете способ подготовиться к определенному экзамену, этот раздел для вас. Здесь вы найдете список сертификатов, каждый из которых ссылается на отдельный файл с целенаправленными вопросами, которые помогут вам подготовиться к экзамену. Удачи :)

#### AWS

* [Cloud Practitioner](certificates/aws-cloud-practitioner.md) (Последнее обновление: 2020)
* [Solutions Architect Associate](certificates/aws-solutions-architect-associate.md) (Последнее обновление: 2021)

#### Azure

* [AZ-900](certificates/azure-fundamentals-az-900.md) (Последнее обновление: 2021)

#### Kubernetes

* [Сертифицированный администратор Kubernetes (CKA)](certificates/cka.md) (Последнее обновление: 2020)

## Другие проекты DevOps

<p align="center"><a href="https://github.com/bregman-arie/howtheydevops"><img src="images/how_they_devops.png"/></a></p>
<p align="center"><a href="https://github.com/bregman-arie/devops-resources"><img src="images/devops_resources.png"/></a></p>
<p align="center"><a href="https://github.com/bregman-arie/infraverse"><img src="images/infraverse.png"/></a></p>

## Кредиты

Спасибо всем нашим замечательным [contributors](https://github.com/bregman-arie/devops-exercises/graphs/contributors), благодаря которым каждый может узнать что-то новое :)

Кредиты на логотипы можно найти [здесь] (credits.md)

## Лицензия

[![Лицензия: CC BY-NC-ND 3.0](https://img.shields.io/badge/License-CC%20BY--NC--ND%203.0-lightgrey.svg)](https://creativecommons.org/licenses/by-nc-nd/3.0/)