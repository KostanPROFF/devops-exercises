## Terraform

<details>
<summary>Объясните, что такое Terraform и как он работает</summary><br><b>

[Terraform.io](https://www.terraform.io/intro/index.html#what-is-terraform-): "Terraform - это инструмент инфраструктуры как кода (IaC), который позволяет безопасно и эффективно создавать, изменять и версионировать инфраструктуру."<br>.
</b></details>

<details>
<summary>Почему лучше использовать Terraform, а не другие технологии? (например, Ansible, Puppet, CloudFormation)</summary><br><b>

Распространенный *неправильный* ответ - сказать, что Ansible и Puppet - это инструменты управления конфигурацией.
а Terraform - это инструмент инициализации. Хотя технически это верно, это не означает, что Ansible и Puppet не могут
использовать для обеспечения инфраструктуры. Также не объясняется, почему Terraform следует использовать вместо
CloudFormation, если это вообще возможно.

Преимущества Terraform перед другими инструментами:

  * Он следует подходу неизменяемой инфраструктуры, который имеет такие преимущества, как предотвращение дрейфа конфигурации с течением времени
  * Ansible и Puppet более процедурные (вы упоминаете, что нужно выполнить на каждом шаге), а Terraform - декларативный, поскольку вы описываете общее желаемое состояние, а не каждый ресурс или задачу. Вы можете привести пример перехода от 1 к 2 серверам в каждом инструменте. В Terraform вы указываете 2, а в Ansible и puppet вам нужно предоставить только 1 дополнительный сервер, поэтому вам нужно явно указать, что вы предоставляете только один сервер.
</b></details>

<details>
<summary>Как вы структурируете свои проекты Terraform? </summary><br><b>

terraform_directory
   providers.tf -> Список провайдеров (источник, версия и т.д.)
   variables.tf -> любая переменная, используемая в других файлах, таких как main.tf
   main.tf -> Перечисляет ресурсы
</b></details>

<details>
<summary>Правда или ложь? Terraform следует парадигме изменяемой инфраструктуры</summary><br><b>

Ложь. Terraform следует парадигме неизменяемой инфраструктуры.
</b></details>

<details>
<summary>Правда или ложь? Terraform использует декларативный стиль для описания ожидаемого конечного состояния</summary><br><b>
Правда
</b></details>

<details>
<summary>Что такое HCL? </summary><br><b>
HCL расшифровывается как Hashicorp Configuration Language. Это язык, который компания Hashicorp сделала для использования в качестве языка конфигурации для ряда своих инструментов, включая terraform.
</b></details>

<details>
<summary>Объясните, что такое "конфигурация Terraform"</summary><br><b>

Конфигурация - это корневой модуль вместе с деревом дочерних модулей, которые называются зависимостями от корневого модуля.
</b></details>

<details>
< резюме> Объясните, что делают следующие команды:

  * <code>terraform init</code>
  * <код>терраформный план</код>
  * <code>terraform validate</code>
  * <code>terraform apply</code>
</summary><br><b>

<code>terraform init</code> сканирует ваш код, чтобы определить, какие провайдеры вы используете, и загружает их.
<code>terraform plan</code> позволит вам увидеть, что собирается сделать terraform, прежде чем сделать это на самом деле.
<code>terraform validate</code> проверяет, является ли конфигурация синтаксически правильной и внутренне согласованной в пределах каталога.
<code>terraform apply</code> обеспечит ресурсы, указанные в .tf файлах.
</b></details>

#### Terraform - Ресурсы

<details>
<summary>Что такое "ресурс"? </summary><br><b>

HashiCorp: "Terraform использует блоки ресурсов для управления инфраструктурой, такой как виртуальные сети, вычислительные экземпляры или компоненты более высокого уровня, такие как записи DNS. Блоки ресурсов представляют собой один или несколько объектов инфраструктуры в конфигурации Terraform".
</b></details>

<details>
<summary>Объясните каждую часть следующей строки: `resource "aws_instance" "web_server" {...}`</summary><br><b>

  - ресурс: ключевое слово для определения ресурса
  - "aws_instance": тип ресурса
  - "web_server": имя ресурса
</b></details>

<details>
<summary>Каков идентификатор следующего ресурса: `resource "aws_instance" "web_server" {...}`</summary><br><b>

`aws_instance.web_server`
</b></details>

<details>
<summary>Правда или ложь? Идентификатор ресурса должен быть уникальным в пределах рабочего пространства</summary><br><b>

Правда
</b></details>

<details>
< резюме> Объясните каждое из следующих положений в отношении ресурсов

  * Аргументы
  * Атрибуты
  * Мета-аргументы</summary><br><b>
  
  - Аргументы: конфигурации, специфичные для ресурсов
  - Атрибуты: значения, выставляемые ресурсом в форме `resource_type.resource_name.attribute_name`. Обычно они устанавливаются провайдером или API.
  - Мета-аргументы: Функции Terraform для изменения поведения ресурса
</b></details>

#### Terraform - Провайдеры

<details>
<summary>Объясните, что такое "провайдер"</summary><br><b>

[terraform.io](https://www.terraform.io/docs/language/providers/index.html): "Terraform полагается на плагины, называемые "провайдерами", для взаимодействия с облачными провайдерами, поставщиками SaaS и другими API... Каждый провайдер добавляет набор типов ресурсов и/или источников данных, которыми Terraform может управлять. Каждый тип ресурса реализуется провайдером; без провайдеров Terraform не может управлять ни одним видом инфраструктуры."
</b></details>

<details>
<summary>Как называется провайдер в данном случае: `resource "libvirt_domain" "instance" {...}`</summary><br><b>

libvirt
</b></details>

#### Terraform - Переменные

<details>
<summary>Что такое входные переменные в Terraform? Почему их нужно использовать? </summary><br><b>

Входные переменные служат параметрами модуля в Terraform. Они позволяют вам, например, один раз определить значение переменной и использовать эту переменную в разных местах модуля, чтобы в следующий раз, когда вы захотите изменить значение, вы изменили его в одном месте, а не меняли значение в разных местах модуля.
</b></details>

<details>
<summary>Как определить переменные?</summary><br><b>

```
переменная "app_id" {
  тип = строка
  описание = "Идентификатор приложения"
  по умолчанию = "некоторое_значение"
}
```

Обычно они определяются в собственном файле (например, vars.tf).
</b></details>

<details>
<summary>Как используются переменные в модулях?</summary><br><b>

На них ссылаются с помощью `var.VARIABLE_NAME`.

vars.tf:

```
переменная "память" {
  тип = строка
  по умолчанию "8192"
}

переменная "cpu" {
  тип = строка
  по умолчанию = "4"
}
```

main.tf:

```
ресурс "libvirt_domain" "vm1" {
   имя = "vm1"
   память = var.memory
   cpu = var.cpu
}
```
</b></details>

<details>
<summary>Как вы заставите пользователей, использующих ваши переменные, предоставлять значения с определенными ограничениями? Например, число больше 1</summary><br><b>

Использование блока `оценка`

```
переменная "some_var" {
  тип = число
  
  валидация {
    условие = var.some_var > 1
    error_message = "необходимо указать число больше 1"
  }

}
```
</b></details>

<details>
<summary>Каков эффект от установки переменной как "чувствительной"?</summary><br><b>

Он не показывает свое значение, когда вы запускаете `terraform apply` или `terraform plan`, но в конечном итоге оно все равно записывается в файл состояния.
</b></details>

<details>
<summary>Истина или ложь? Если результат выражения зависит от чувствительной переменной, она также будет считаться чувствительной</summary><br><b>

Правда
</b></details>

<details>
<summary> Одна и та же переменная определена в следующих местах:

  - Файл `terraform.tfvars`
  - Переменная среды
  - Использование `-var` или `-var-file`
  
В соответствии с приоритетом переменных, какой источник будет использован первым? </summary><br><b>

Порядок такой:

  - Переменная среды
  - Файл `terraform.tfvars`
  - Использование `-var` или `-var-file`
</b></details>

<details>
<summary>Каким еще способом можно определить множество переменных более "упрощенным" способом?</summary><br><b>

Использование файла `.tfvars`, который содержит переменную, состоящую из простых имен переменных, назначается таким образом:

```
x = 2
y = "марио"
z = "Луиджи"
```
</b></details>

#### Terraform - Государство

<details>
<summary>Для чего используется файл <code>terraform.tfstate</code>? </summary><br><b>

Он отслеживает идентификаторы созданных ресурсов, чтобы Terraform знал, чем он управляет.
</b></details>

<details>
<summary>Как переименовать существующий ресурс?</summary><br><b>

государство терраформ мв
</b></details>

<details>
<summary>Почему важно, где хранить файл tfstate? Где бы вы его хранили? </summary><br><b>

  - tfstate содержит учетные данные в виде обычного текста. Не стоит размещать его в общедоступном месте.
  - tfstate не должен изменяться одновременно, поэтому размещение его в общем месте, доступном для всех с правами "запись", может привести к проблемам. (Удаленное состояние Terraform не имеет такой проблемы).
  - tfstate является важным файлом. Поэтому, возможно, лучше поместить его в место, где регулярно создаются резервные копии.

Поэтому tfstate не следует хранить в git-репозиториях. Лучшим вариантом является защищенное хранение, например, защищенные ведра.
</b></details>

<details>
<summary>Какая команда отвечает за создание файла состояния? </summary><br><b>

  - terraform apply file.terraform
  - Вышеприведенная команда создаст файл tfstate в рабочей папке.
</b></details>

<details>
<summary>По умолчанию где хранится состояние? </summary><br><b>

  - По умолчанию состояние хранится в локальном файле с именем terraform.tfstate.
</b></details>

<details>
<summary>Можно ли хранить файл tfstate в удаленном месте? Если да, то при каких условиях вы будете это делать? </summary><br><b>

  - Да, его также можно хранить удаленно, что лучше работает в командной среде. При условии, что удаленное расположение не является общедоступным, поскольку файл tfstate содержит также конфиденциальную информацию. Доступ к этому удаленному местоположению должен быть открыт только для членов команды.
</b></details>

<details>
<summary>Упомяните некоторые лучшие практики, связанные с tfstate</summary><br><b>

  - Не редактируйте его вручную. tfstate был разработан для манипуляций с terraform, а не для пользователей напрямую.
  - Храните его в защищенном месте (поскольку он может содержать учетные данные и вообще конфиденциальную информацию)
  - Регулярно создавайте резервные копии, чтобы в случае необходимости можно было легко откатиться назад. 
  - Храните его в удаленном общем хранилище. Это особенно необходимо при работе в команде, когда состояние может быть обновлено любым из членов команды.
  - Включите версионирование, если хранилище, в котором вы храните файл состояния, поддерживает его. Версионирование отлично подходит для резервного копирования и отката в случае возникновения проблем.
</b></details>

<details>
<summary>Как и почему следует избегать одновременного редактирования файла состояния?</summary><br><b>

Если два пользователя или процесса одновременно редактируют файл состояния, это может привести к некорректному файлу состояния, который на самом деле не представляет состояние ресурсов.<br>.

Чтобы избежать этого, Terraform может применить блокировку состояния, если бэкенд поддерживает это. Например, AWS s3 поддерживает блокировку состояния и согласованность через DynamoDB. Часто, если бэкенд поддерживает это, Terraform будет использовать блокировку состояния автоматически, поэтому от пользователя ничего не требуется для ее активации.
</b></details>

<details>
<summary> Опишите, как вы управляете файлом(ами) состояния, когда у вас есть несколько сред (например, разработка, постановка и производство)</summary><br><b>

Здесь нет правильного или неправильного, но кажется, что в целом предпочтительнее иметь отдельный файл состояния для каждой среды.
</b></details>

<details>
<summary>Как записать переменную, которая изменяется внешним источником или во время <code>terraform apply</code>? </summary><br><b>

Вы используете его следующим образом: <код>переменная "my_var" {}</код>.
</b></details>

<details>
<summary>Вы развернули виртуальную машину с помощью Terraform и хотите передать ей данные (или выполнить некоторые команды). Какую концепцию Terraform вы бы использовали? </summary><br><b>

[Provisioners](https://www.terraform.io/docs/language/resources/provisioners)
</b></details>

#### Terraform - Provisioners

<details>
<summary>Что такое "Провизионеры"? Для чего они используются? </summary><br><b>

Провизионеры используются для выполнения действий на локальной или удаленной машине. Это очень полезно в случае, если вы создали экземпляр и хотите сделать пару изменений на созданной машине без необходимости вручную заходить на нее после завершения работы Terraform и запускать их вручную.
</b></details>

<details>
<summary>Что такое <code>local-exec</code> и <code>remote-exec</code> в контексте провайдеров? </summary><br><b>
</b></details>

<details>
<summary>Что такое "испорченный ресурс"? </summary><br><b>

Это ресурс, который был успешно создан, но потерпел неудачу во время инициализации. Terraform потерпит неудачу и пометит этот ресурс как "испорченный".
</b></details>

<details>
<summary>Что делает <code>terraform taint</code>? </summary><br><b>
<code>terraform taint resource.id</code> вручную помечает ресурс как испорченный в файле состояния. Таким образом, когда вы запустите <code>terraform apply</code> в следующий раз, ресурс будет уничтожен и создан заново.
</b></details>

<details>
<summary>Какие типы переменных поддерживаются в Terraform? </summary><br><b>

строка
номер
bool
список(< ТИП>)
set(< TYPE>)
map(< TYPE>)
object({< ATTR_NAME> = < TYPE>, ... })
кортеж([< ТИП>, ...])
</b></details>

<details>
<summary>Что такое источник данных? В каких сценариях, например, его нужно использовать? </summary><br><b>
Источники данных ищут или вычисляют значения, которые могут быть использованы в других местах конфигурации терраформы.

Существует довольно много случаев, когда вам может понадобиться их использовать:
* вы хотите ссылаться на ресурсы, не управляемые через терраформу
* вы хотите ссылаться на ресурсы, управляемые другим модулем терраформы
* вы хотите чисто вычислить значение с проверкой типов, например, с помощью <code>aws_iam_policy_document</code>.
</b></details>

<details>
<summary>Что такое выходные переменные и что делает <code>terraform output</code>? </summary><br><b>
Выходные переменные - это именованные значения, которые берутся из атрибутов модуля. Они хранятся в состоянии терраформы и могут быть использованы другими модулями через <code>remote_state</code>.
</b></details>

<details>
<summary>Объяснение модулей</summary>

Модуль Terraform - это набор конфигурационных файлов Terraform в одном каталоге. Модули - это небольшие, многократно используемые конфигурации Terraform, которые позволяют вам управлять группой связанных ресурсов так, как будто это один ресурс. Даже простая конфигурация, состоящая из одного каталога с одним или несколькими файлами .tf, является модулем. Когда вы запускаете команды Terraform непосредственно из такого каталога, он считается корневым модулем. Таким образом, в этом смысле каждая конфигурация Terraform является частью модуля.
</b></details>

<details>
<summary>Что такое реестр Terraform? </summary><br><b>

Реестр Terraform предоставляет централизованное место для официальных и управляемых сообществом провайдеров и модулей.
</b></details>

<details>
<summary>Объясните <code>remote-exec</code> и <code>local-exec</code></summary><br><b>
</b></details>


<details>
<summary>Объясните понятие "удаленное состояние". Когда вы будете его использовать и как? </summary><br><b>
  Terraform генерирует json-файл `terraform.tfstate`, описывающий компоненты/услуги, предоставленные указанным провайдером. Удаленный
  Государство хранит этот файл на удаленном носителе, чтобы обеспечить совместную работу команды.
</b></details>

<details>
<summary>Объясните "Блокировку состояния"</summary><br><b>
  Блокировка состояния - это механизм, который блокирует операции над определенным файлом состояния от нескольких абонентов, чтобы избежать конфликтующих операций от разных членов команды. Как только блокировка операции первого абонента будет снята, другой член команды может приступать к выполнению операции
  выполнять свою собственную операцию. Тем не менее, Terraform сначала проверит файл состояния на предмет того, существует ли уже нужный ресурс и
  если нет, он продолжает его создавать.
</b></details>

<details>
<summary>Что такое провайдер "Random"? Для чего он используется</summary><br><b>
 Случайный поставщик помогает генерировать цифровые или буквенные символы для использования в качестве префикса или суффикса для желаемого именованного идентификатора.
</b></details>

<details>
<summary>Как протестировать модуль терраформы?</summary><br><b>
  Можно привести много примеров, но наиболее распространенным ответом будет использование инструмента <code>terratest</code> и проверка того, что модуль может быть инициализирован, может создавать ресурсы и может уничтожать эти ресурсы.
</b></details>

<details>
<summary>Помимо файлов <code>.tfvars</code> или аргументов CLI, как можно внедрить зависимости из других модулей?</summary><br><b>
  Встроенный в terraform способ заключается в использовании <code>remote-state</code> для поиска выходов из других модулей.
  В сообществе также распространено использование инструмента под названием <code>terragrunt</code> для явного внедрения переменных между модулями.
</b></details>

<details>
<summary>Что такое импорт Terraform? </summary><br><b>

Terraform import используется для импорта существующей инфраструктуры. Он позволяет принести ресурсы, созданные другими способами (например, запущенные вручную облачные ресурсы), и передать их под управление Terraform. 
</b></details>

<details>
<summary>Как импортировать существующий ресурс с помощью Terraform import?</summary><br><b>

1. Определите, какой ресурс вы хотите импортировать.
2. Напишите код терраформирования, соответствующий конфигурации данного ресурса.
3. Выполните команду terraform <code>terraform import RESOURCE ID</code><br>

например. Допустим, вы хотите импортировать экземпляр aws. Тогда вы выполните следующие действия:
1. Определите этот экземпляр aws в консоли
2. Обратитесь к его конфигурации и напишите код Terraform, который будет выглядеть примерно так:
```
ресурс "aws_instance" "tf_aws_instance" {
  ami = data.aws_ami.ubuntu.id
  instance_type = "t3.micro"

  теги = {
    Имя = "import-me"
  }
}
```
3. Запустите команду terraform <код>terraform import aws_instance.tf_aws_instance i-12345678</код>.
</b></details>
