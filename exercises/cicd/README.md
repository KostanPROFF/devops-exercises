## CI/CD

### Упражнения CI/CD

|Name|Topic|Objective & Instructions|Solution|Comments|
|--------|--------|------|----|----|
| Настройка конвейера CI | CI | [Exercise](ci_for_open_source_project.md) | | | | |
| Развертывание в Kubernetes | Развертывание | [Упражнение](deploy_to_kubernetes.md) | [Решение](solutions/deploy_to_kubernetes/README.md) | | |
| Jenkins - Remove Jobs | Jenkins Scripts | [Exercise](remove_jobs.md) | [Solution](solutions/remove_jobs_solution.groovy) | | | |
| Jenkins - Remove Builds | Скрипты Jenkins | [Exercise](remove_builds.md) | [Solution](solutions/remove_builds_solution.groovy) | | |

### Самооценка CI/CD

<details>
<summary>Что такое непрерывная интеграция? </summary><br><b>

Практика разработки, при которой разработчики часто интегрируют код в общий репозиторий. Это может варьироваться от пары изменений каждый день или неделю до пары изменений за один час в больших масштабах.

Каждый фрагмент кода (изменение/патч) проверяется, чтобы убедиться, что изменение безопасно для слияния. Сегодня общепринятой практикой является тестирование изменений с помощью автоматизированной сборки, которая гарантирует, что код может быть интегрирован. Это может быть одна сборка, в которой выполняется несколько тестов разного уровня (модульные, функциональные и т.д.) или несколько отдельных сборок, которые должны пройти все или некоторые из них, чтобы изменение было слито в репозиторий.
</b></details>

<details>
<summary>Что такое непрерывное развертывание? </summary><br><b>

Стратегия разработки, используемая разработчиками для автоматического выпуска программного обеспечения в производство, при которой любая фиксация кода должна пройти через фазу автоматизированного тестирования. Только после успешного тестирования релиз считается пригодным для производства. Это исключает любое взаимодействие с человеком и должно быть реализовано только после создания готовых к производству конвейеров с мониторингом и отчетностью в реальном времени о развернутых активах. При обнаружении каких-либо проблем в продакшене должен быть обеспечен легкий откат к предыдущему рабочему состоянию.

Для получения дополнительной информации, пожалуйста, прочитайте [здесь](https://www.atlassian.com/continuous-delivery/continuous-deployment)
</b></details>

<details>
<summary>Можете ли вы описать пример процесса CI (и/или CD), начинающегося в тот момент, когда разработчик отправил изменение/PR в репозиторий?</summary><br><b>

На такой вопрос существует множество ответов, поскольку процессы CI различаются в зависимости от используемых технологий и типа проекта, в который было внесено изменение.
Такие процессы могут включать один или несколько из следующих этапов:

* Компиляция 
* Построить
* Установить
* Настроить
* Обновление
* Тест

Пример одного из возможных ответов:

Разработчик подал запрос на внесение изменений в проект. PR (pull request) вызвал два задания (или одно комбинированное задание). Одно задание для выполнения lint-теста изменения, а второе задание для создания пакета, включающего представленное изменение, и выполнения нескольких api/сценариев тестов с использованием этого пакета. Как только все тесты пройдены и изменение одобрено мейнтейнером/ядром, оно сливается/помещается в репозиторий. Если некоторые тесты не прошли, изменение не будет разрешено к слиянию/помещению в репозиторий.

Совершенно другой ответ или процесс CI может описывать, как разработчик помещает код в репозиторий, после чего запускается рабочий процесс для создания образа контейнера и отправки его в реестр. После попадания в реестр кластер k8s применяется с новыми изменениями.
</b></details>

<details>
<summary>Что такое Continuous Delivery? </summary><br><b>

Стратегия разработки, используемая для частой передачи кода в QA и Ops для тестирования. Это подразумевает наличие "зоны ожидания" с функциями, подобными производственным, где изменения могут быть приняты в производство только после ручной проверки. Из-за этого вмешательства человека обычно существует временной лаг между выпуском и проверкой, что делает процесс более медленным и подверженным ошибкам по сравнению с непрерывным развертыванием.

Для получения дополнительной информации, пожалуйста, прочитайте [здесь](https://www.atlassian.com/continuous-delivery/continuous-deployment)
</b></details>

<details>
<summary>Чем отличается Continuous Delivery от Continuous Deployment? </summary><br><b>

Оба они включают в себя один и тот же процесс развертывания изменений, которые были скомпилированы и/или протестированы в конвейерах CI.< br>
Разница между ними заключается в том, что непрерывная доставка не является полностью автоматизированным процессом, в отличие от непрерывного развертывания, где каждое изменение, которое тестируется в процессе, в конечном итоге развертывается на производстве. В непрерывной доставке кто-то либо утверждает процесс развертывания, либо процесс развертывания основан на ограничениях и условиях (например, ограничение по времени развертывания каждую неделю/месяц/...).
</b></details>

<details>
<summary>С какими лучшими практиками CI/CD вы знакомы? Или что вы считаете лучшей практикой CI/CD? </summary><br><b>

* Часто выполняйте и тестируйте.
* Тестовая/постановочная среда должна быть клоном производственной среды.
* Очистите свои среды (например, ваши CI/CD конвейеры могут создавать много ресурсов. Они также должны заботиться об очистке всего, что они создают)
* Конвейеры CI/CD должны обеспечивать одинаковые результаты при локальном и удаленном выполнении
* Относитесь к CI/CD как к еще одному приложению в вашей организации. А не как клеевой код.
* Среды по требованию вместо предварительно выделенных ресурсов для целей CI/CD
* Этапы/шаги/задачи конвейеров должны быть общими для приложений или микросервисов (не изобретайте заново общие задачи вроде "клонирования проекта").
</b></details>

<details>
<summary>Вам дан конвейер и пул с 3 рабочими: виртуальная машина, baremetal и контейнер. Как вы решите, кто из них будет запускать конвейер? </summary><br><b>
</b></details>

<details>
<summary>Где вы храните конвейеры CI/CD? Почему? </summary><br><b>

Существует несколько подходов к тому, где хранить определения конвейера CI/CD:

1. App Repository - хранить их в том же репозитории приложения, которое они создают или тестируют (пожалуй, самый популярный вариант).
2. Центральный репозиторий - хранение всех CI/CD трубопроводов организации/проекта в одном отдельном репозитории (возможно, лучший подход, когда несколько команд тестируют один и тот же набор проектов и в итоге имеют много трубопроводов).
3. CI-репо для каждого репо приложения - вы отделяете код, связанный с CI, от кода приложения, но не помещаете все в одно место (возможно, худший вариант из-за необходимости обслуживания).
4. Платформа, на которой выполняются конвейеры CI/CD (например, кластер Kubernetes в случае конвейеров Tekton/OpenShift).
</b></details>

<details>
<summary>Как вы осуществляете планирование емкости для ваших ресурсов CI/CD? (например, серверы, хранилища и т. д.)</summary><br><b>
</b></details>

<details>
<summary>Как бы вы структурировали/реализовали CD для приложения, которое зависит от нескольких других приложений?</summary><br><b>
</b></details>

<details>
<summary>Как вы измеряете качество CI/CD? Есть ли метрики или KPI, которые вы используете для измерения качества? </summary><br><b>
</b></details>

#### CI/CD - Jenkins

<details>
<summary>Что такое Jenkins? Для чего вы его использовали? </summary><br><b>

Jenkins - это инструмент автоматизации с открытым исходным кодом, написанный на Java с плагинами, созданными для целей непрерывной интеграции. Jenkins используется для непрерывной сборки и тестирования ваших программных проектов, облегчая разработчикам интеграцию изменений в проект, а пользователям - получение свежей сборки. Он также позволяет непрерывно поставлять программное обеспечение благодаря интеграции с большим количеством технологий тестирования и развертывания.

Jenkins интегрирует всевозможные процессы жизненного цикла разработки, включая сборку, документирование, тестирование, упаковку, этап, развертывание, статический анализ и многое другое.

</b></details>

<details>
< резюме> В чем преимущества Jenkins перед конкурентами? Можете ли вы сравнить его с одной из следующих систем?

  * Travis
  * Бамбук
  * Teamcity
  * CircleCI</summary><br><b>
</b></details>

<details>
<summary>Каковы ограничения или недостатки Jenkins? </summary><br><b>

Это может быть расценено как ответ, основанный на собственном мнении:

* Старые приборные панели с небольшим количеством опций для настройки.
* Готовность контейнеров (это улучшилось с появлением Jenkins X)
* Сам по себе он не обладает большим количеством функций. С другой стороны, существует множество плагинов, созданных сообществом для расширения его возможностей
* Управление Jenkins и его трубопроводами в виде кода может стать настоящим кошмаром.
</b></details>

<details>
< резюме> Объясните следующее:

- Работа
- Строить
- Плагин
- Узел или рабочий
- Исполнитель</summary><br><b>
- Job - это определение автоматизации = что и где должно быть выполнено после того, как пользователь нажмет на кнопку "build". 
- Сборка - это запущенный экземпляр задания. Вы можете иметь одну или несколько сборок в любой момент времени (если это не ограничено конфигурацией).
- Рабочий - это машина/экземпляр, на котором выполняется сборка. Когда сборка запускается, она "приобретает" рабочего из пула для работы на нем.
- Исполнитель - это переменная рабочего, определяющая, сколько сборок может выполняться на этом рабочем параллельно. Значение executor, равное 3, означает, что в любой момент на этом исполнителе могут выполняться 3 сборки (не обязательно одного и того же задания. Любые сборки).
</b></details>

<details>
<summary>Какие плагины вы использовали в Jenkins? </summary><br><b>
</b></details>

<details>
<summary>Вы использовали Jenkins для процессов CI или CD? Можете ли вы описать их? </summary><br><b>
</b></details>

<details>
<summary>Какие существуют типы рабочих мест? Какие типы вы использовали? </summary><br><b>
</b></details>

<details>
<summary>Как вы сообщали пользователям о результатах сборки? Какие существуют способы сообщить о результатах? </summary><br><b>

Вы можете сообщить об этом через:
  * Электронная почта
  * Приложения для обмена сообщениями
  * Приборные панели

Каждый из них имеет свои недостатки и преимущества. Например, электронные письма, если их отправлять слишком часто, могут быть в конечном итоге проигнорированы или не приняты во внимание.
</b></details>

<details>
<summary>Вам необходимо запускать модульные тесты при каждом изменении, вносимом в проект. Опишите в деталях, как будет выглядеть ваш конвейер и что будет выполняться на каждом этапе</summary><br><b>

Трубопроводы будут иметь несколько этапов:

  * Клонировать проект
  * Установите тестовые зависимости (например, если мне нужен пакет tox для запуска тестов, я установлю его на этом этапе).
  * Выполнить модульные тесты
  * (Необязательно) отчет о результатах (Например, электронное письмо пользователям).
  * Архивировать соответствующие журналы/файлы
</b></details>

<details>
<summary>Как защитить Jenkins? </summary><br><b>

 [Документация Jenkins](https://www.jenkins.io/doc/book/security/securing-jenkins/) содержит некоторые базовые вводные по обеспечению безопасности вашего сервера Jenkins.
</b></details>

<details>
<summary>Опишите, как добавлять новые узлы (агенты) в Jenkins</summary><br><b>

Вы можете описать способ добавления новых узлов с помощью пользовательского интерфейса, но лучше объяснить, как это сделать масштабируемым способом, например, скриптом или используя динамический источник для узлов, как в одном из существующих облаков.
</b></details>

<details>
<summary>Как получить несколько узлов для одной конкретной сборки?</summary><br><b>
</b></details>

<details>
<summary>Когда сборка не удается, вы хотели бы уведомить команду, владеющую заданием, о неудаче и указать причину неудачи. Как бы вы это сделали? </summary><br><b>
</b></details>

<details>
< резюме> В вашей организации есть четыре команды. Как расставить приоритеты между сборками каждой команды? Например, чтобы задания команды x всегда выполнялись раньше, чем задания команды y</summary><br><b>
</b></details>

<details>
<summary>Если вы управляете десятком заданий, вы, вероятно, можете использовать пользовательский интерфейс Jenkins. Но как управлять созданием и удалением сотен заданий каждую неделю/месяц? </summary><br><b>
</b></details>

<details>
<summary>Каковы некоторые ограничения Jenkins? </summary><br><b>

  * Тестирование кросс-зависимостей (изменения из нескольких проектов вместе).
  * Запуск сборки с любого этапа (хотя Cloudbees реализовал нечто, называемое контрольными точками)
</b></details>

<details>
<summary>Чем отличается скриптовый трубопровод от декларативного трубопровода? Какой тип вы используете? </summary><br><b>
</b></details>

<details>
<summary>Как бы вы реализовали возможность запуска сборки с определенного этапа, а не с начала?</summary><br><b>
</b></details>

<details>
<summary>У вас есть опыт разработки плагина Jenkins? Можете ли вы описать этот опыт? </summary><br><b>
</b></details>

<details>
<summary>Писали ли вы скрипты Jenkins? Если да, то для чего и как они работают? </summary><br><b>
</b></details>

#### CI/CD - GitHub Actions

<details>
<summary>Что такое рабочий процесс в GitHub Actions? </summary><br><b>

YAML-файл, определяющий действия и инструкции автоматизации для выполнения при определенном событии.< br>
Файл помещается в само хранилище.

Рабочий процесс может быть любым - выполнение тестов, компиляция кода, сборка пакетов, ...
</b></details>

<details>
<summary>Что такое Runner в GitHub Actions? </summary><br><b>

Рабочий процесс должен где-то выполняться. Среда, в которой выполняется рабочий процесс, называется Runner.< br>
Runner может быть локальным хостом или хостом GitHub.
</b></details>

<details>
<summary>Что такое задание в GitHub Actions? </summary><br><b>

Задание - это серия шагов, которые выполняются на одном и том же исполнителе/окружении.< br>
Рабочий процесс должен включать как минимум одно задание.
</b></details>

<details>
<summary>Что такое действие в GitHub Actions? </summary><br><b>

Действие - это наименьшая единица в рабочем процессе. Оно включает команды для выполнения в рамках задания.
</b></details>

<details>
<summary>В рабочем процессе GitHub Actions для чего используется атрибут/директива 'on'? </summary><br><b>

Укажите, при каких событиях будет запускаться рабочий процесс.< br>
Например, вы можете настроить рабочий процесс так, чтобы он срабатывал каждый раз, когда в хранилище вносится изменение.
</b></details>

<details>
<summary>Правда или ложь? В Github Actions задания выполняются параллельно с помощью deafult</summary><br><b>

Правда
</b></details>

<details>
<summary>Как создать зависимости между заданиями, чтобы одно задание выполнялось после другого?</summary><br><b>

Использование атрибута/директивы "потребности".

```
работы:
  работа1:
  работа2:
    потребности: работа1
```

В приведенном выше примере задание1 должно успешно завершиться до выполнения задания2
</b></details>

<details>
<summary>Как добавить рабочий процесс в хранилище?</summary><br><b>
CLI:

1. Создайте каталог `.github/workflows` в репозитории
2. Добавьте файл YAML

UI:

1. На странице репозитория нажмите "Действия".
2. Выберите рабочий процесс и нажмите "Настроить этот рабочий процесс".
</b></details>

#### Zuul

<details>
<summary>В Zuul, Что такое <code>check</code> трубопроводы? </summary><br><b>

Конвейер `check` запускается, когда патч загружается в систему проверки кода (например, Gerrit).< br>
</b></details>

<details>
<summary>В Зууле, Что такое <code>гейт</code> трубопроводы? </summary><br><b>

Конвейер `gate` запускается, когда рецензент кода утверждает изменение в системе проверки кода (например, Gerrit).
</b></details>

<details>
<summary>Истина или ложь? <code>gate</code> трубопроводы запускаются после <code>check</code> трубопроводов</summary><br><b>

Верно. Конвейер `check` запускается, когда изменение загружено, а конвейеры `gate` запускаются, когда изменение одобрено рецензентом.
</b></details>
